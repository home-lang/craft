package {{PACKAGE_NAME}}

import android.Manifest
import android.app.Activity
import android.content.ClipData
import android.content.ClipboardManager
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.graphics.Bitmap
import android.hardware.camera2.CameraAccessException
import android.hardware.camera2.CameraCharacteristics
import android.hardware.camera2.CameraManager
import android.location.Location
import android.net.ConnectivityManager
import android.net.Network
import android.net.NetworkCapabilities
import android.net.NetworkRequest
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.os.Looper
import android.os.VibrationEffect
import android.os.Vibrator
import android.os.VibratorManager
import android.provider.MediaStore
import android.provider.Settings
import android.speech.RecognitionListener
import android.speech.RecognizerIntent
import android.speech.SpeechRecognizer
import android.util.DisplayMetrics
import android.webkit.JavascriptInterface
import android.webkit.WebView
import androidx.biometric.BiometricManager
import androidx.biometric.BiometricPrompt
import androidx.core.app.ActivityCompat
import androidx.core.app.NotificationManagerCompat
import androidx.core.content.ContextCompat
import androidx.fragment.app.FragmentActivity
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.LifecycleEventObserver
import androidx.lifecycle.ProcessLifecycleOwner
import androidx.security.crypto.EncryptedSharedPreferences
import androidx.security.crypto.MasterKey
import com.google.android.gms.location.FusedLocationProviderClient
import com.google.android.gms.location.LocationCallback
import com.google.android.gms.location.LocationRequest
import com.google.android.gms.location.LocationResult
import com.google.android.gms.location.LocationServices
import com.google.android.gms.location.Priority
import com.google.android.play.core.review.ReviewManagerFactory
import android.content.ContentResolver
import android.content.ContentUris
import android.content.ContentValues
import android.database.Cursor
import android.provider.CalendarContract
import android.provider.ContactsContract
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.view.WindowManager
import android.content.pm.ActivityInfo
import com.android.billingclient.api.*
import org.json.JSONObject
import org.json.JSONArray
import java.util.Locale
import java.util.concurrent.Executor
import java.util.Calendar
import java.util.TimeZone
import android.media.MediaRecorder
import android.hardware.Sensor
import android.hardware.SensorEvent
import android.hardware.SensorEventListener
import android.hardware.SensorManager
import android.database.sqlite.SQLiteDatabase
import android.bluetooth.BluetoothAdapter
import android.bluetooth.BluetoothManager
import android.bluetooth.le.BluetoothLeScanner
import android.bluetooth.le.ScanCallback
import android.bluetooth.le.ScanResult
import android.nfc.NfcAdapter
import android.nfc.tech.Ndef
import android.app.DownloadManager
import android.view.View
import android.util.Base64
import com.google.mlkit.vision.barcode.BarcodeScanning
import com.google.mlkit.vision.common.InputImage
import com.google.mlkit.vision.label.ImageLabeling
import com.google.mlkit.vision.label.defaults.ImageLabelerOptions
import com.google.mlkit.vision.objects.ObjectDetection
import com.google.mlkit.vision.objects.defaults.ObjectDetectorOptions
import com.google.mlkit.vision.text.TextRecognition
import com.google.mlkit.vision.text.latin.TextRecognizerOptions
import android.graphics.BitmapFactory
import java.io.ByteArrayOutputStream
import java.io.File
import java.util.concurrent.TimeUnit

class CraftBridge(
    private val activity: Activity,
    private val webView: WebView
) {
    private var speechRecognizer: SpeechRecognizer? = null
    private var isListening = false
    private val mainExecutor: Executor = ContextCompat.getMainExecutor(activity)

    // Location tracking
    private var fusedLocationClient: FusedLocationProviderClient? = null
    private var locationCallback: LocationCallback? = null
    private var watchId = 0

    // Network monitoring
    private var networkCallback: ConnectivityManager.NetworkCallback? = null

    // Flashlight state
    private var isFlashlightOn = false

    // App state tracking
    private var currentAppState = "active"

    // Keep awake
    private var isKeepingAwake = false

    // Billing client for in-app purchases
    private var billingClient: BillingClient? = null

    // Notification channel ID
    private val notificationChannelId = "craft_notifications"

    // Audio recording
    private var mediaRecorder: MediaRecorder? = null
    private var audioFile: File? = null

    // Motion sensors
    private var sensorManager: SensorManager? = null
    private var accelerometer: Sensor? = null
    private var gyroscope: Sensor? = null
    private var sensorListener: SensorEventListener? = null

    // SQLite database
    private var database: SQLiteDatabase? = null

    // Bluetooth
    private var bluetoothAdapter: BluetoothAdapter? = null
    private var bluetoothScanner: BluetoothLeScanner? = null
    private var bleScanCallback: ScanCallback? = null

    // Encrypted shared preferences for secure storage
    private val masterKey by lazy {
        MasterKey.Builder(activity)
            .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
            .build()
    }

    private val securePrefs by lazy {
        EncryptedSharedPreferences.create(
            activity,
            "craft_secure_prefs",
            masterKey,
            EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
            EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
        )
    }

    fun injectBridge() {
        val script = """
            window.craft = {
                platform: 'android',
                capabilities: {
                    haptics: true,
                    speechRecognition: ${SpeechRecognizer.isRecognitionAvailable(activity)},
                    share: true,
                    camera: true,
                    biometric: ${isBiometricAvailable()},
                    pushNotifications: true,
                    secureStorage: true,
                    geolocation: true,
                    clipboard: true,
                    deviceInfo: true,
                    appBadge: true,
                    networkStatus: true,
                    appReview: true,
                    flashlight: ${hasFlashlight()},
                    openURL: true,
                    vibrationPattern: true,
                    appState: true,
                    contacts: true,
                    calendar: true,
                    localNotifications: true,
                    inAppPurchase: true,
                    keepAwake: true,
                    orientationLock: true,
                    deepLinks: true,
                    qrScanner: true,
                    filePicker: true,
                    fileDownload: true,
                    googleSignIn: true,
                    audioRecording: true,
                    videoRecording: true,
                    motionSensors: true,
                    localDatabase: true,
                    bluetooth: true,
                    nfc: ${NfcAdapter.getDefaultAdapter(activity) != null},
                    fitness: true,
                    screenCapture: true
                },

                // Haptic feedback
                haptic: function(style) {
                    CraftAndroid.haptic(style || 'medium');
                },

                // Speech recognition
                startListening: function() {
                    CraftAndroid.startListening();
                },
                stopListening: function() {
                    CraftAndroid.stopListening();
                },

                // Share
                share: function(text, title) {
                    CraftAndroid.share(text, title || '');
                },

                // Camera
                openCamera: function() {
                    return new Promise(function(resolve, reject) {
                        window._craftCameraResolve = resolve;
                        window._craftCameraReject = reject;
                        CraftAndroid.openCamera();
                    });
                },
                pickImage: function() {
                    return new Promise(function(resolve, reject) {
                        window._craftGalleryResolve = resolve;
                        window._craftGalleryReject = reject;
                        CraftAndroid.pickImage();
                    });
                },

                // Biometric auth
                authenticate: function(reason) {
                    return new Promise(function(resolve, reject) {
                        window._craftBiometricResolve = resolve;
                        window._craftBiometricReject = reject;
                        CraftAndroid.authenticate(reason || 'Authenticate to continue');
                    });
                },

                // Push notifications
                registerPush: function() {
                    return new Promise(function(resolve, reject) {
                        window._craftPushResolve = resolve;
                        window._craftPushReject = reject;
                        CraftAndroid.registerPush();
                    });
                },

                // Secure storage
                secureStore: {
                    set: function(key, value) {
                        return CraftAndroid.secureSet(key, value);
                    },
                    get: function(key) {
                        return CraftAndroid.secureGet(key);
                    },
                    remove: function(key) {
                        return CraftAndroid.secureRemove(key);
                    }
                },

                // Geolocation
                getCurrentPosition: function(options) {
                    return new Promise(function(resolve, reject) {
                        window._craftLocationResolve = resolve;
                        window._craftLocationReject = reject;
                        CraftAndroid.getCurrentPosition(JSON.stringify(options || {}));
                    });
                },
                watchPosition: function(callback, options) {
                    var watchId = CraftAndroid.watchPosition(JSON.stringify(options || {}));
                    window['_craftLocationWatch_' + watchId] = callback;
                    return watchId;
                },
                clearWatch: function(watchId) {
                    CraftAndroid.clearWatch(watchId);
                    delete window['_craftLocationWatch_' + watchId];
                },

                // Clipboard
                clipboard: {
                    read: function() {
                        return new Promise(function(resolve) {
                            resolve(CraftAndroid.clipboardRead());
                        });
                    },
                    write: function(text) {
                        return new Promise(function(resolve) {
                            resolve(CraftAndroid.clipboardWrite(text));
                        });
                    }
                },

                // Device Info
                getDeviceInfo: function() {
                    return JSON.parse(CraftAndroid.getDeviceInfo());
                },

                // App Badge
                setBadge: function(count) {
                    CraftAndroid.setBadge(count);
                },
                clearBadge: function() {
                    CraftAndroid.clearBadge();
                },

                // Network Status
                getNetworkStatus: function() {
                    return JSON.parse(CraftAndroid.getNetworkStatus());
                },
                onNetworkChange: function(callback) {
                    window._craftNetworkChangeCallback = callback;
                    CraftAndroid.startNetworkMonitoring();
                },
                offNetworkChange: function() {
                    window._craftNetworkChangeCallback = null;
                    CraftAndroid.stopNetworkMonitoring();
                },

                // App Review
                requestReview: function() {
                    return new Promise(function(resolve, reject) {
                        window._craftReviewResolve = resolve;
                        window._craftReviewReject = reject;
                        CraftAndroid.requestReview();
                    });
                },

                // Flashlight
                setFlashlight: function(on) {
                    return CraftAndroid.setFlashlight(on);
                },
                toggleFlashlight: function() {
                    return CraftAndroid.toggleFlashlight();
                },

                // Open URL
                openURL: function(url) {
                    return CraftAndroid.openURL(url);
                },

                // Vibration Pattern
                vibrate: function(pattern) {
                    CraftAndroid.vibrate(JSON.stringify(pattern));
                },

                // App State
                getAppState: function() {
                    return CraftAndroid.getAppState();
                },
                onAppStateChange: function(callback) {
                    window._craftAppStateCallback = callback;
                    CraftAndroid.startAppStateMonitoring();
                },
                offAppStateChange: function() {
                    window._craftAppStateCallback = null;
                    CraftAndroid.stopAppStateMonitoring();
                },

                // Contacts
                contacts: {
                    getAll: function() {
                        return new Promise(function(resolve, reject) {
                            window._craftContactsResolve = resolve;
                            window._craftContactsReject = reject;
                            CraftAndroid.getContacts();
                        });
                    },
                    add: function(contact) {
                        return new Promise(function(resolve, reject) {
                            window._craftAddContactResolve = resolve;
                            window._craftAddContactReject = reject;
                            CraftAndroid.addContact(JSON.stringify(contact));
                        });
                    }
                },

                // Calendar
                calendar: {
                    getEvents: function(startDate, endDate) {
                        return new Promise(function(resolve, reject) {
                            window._craftCalendarResolve = resolve;
                            window._craftCalendarReject = reject;
                            CraftAndroid.getCalendarEvents(startDate || 0, endDate || 0);
                        });
                    },
                    createEvent: function(event) {
                        return new Promise(function(resolve, reject) {
                            window._craftCreateEventResolve = resolve;
                            window._craftCreateEventReject = reject;
                            CraftAndroid.createCalendarEvent(JSON.stringify(event));
                        });
                    },
                    deleteEvent: function(eventId) {
                        return new Promise(function(resolve, reject) {
                            window._craftDeleteEventResolve = resolve;
                            window._craftDeleteEventReject = reject;
                            CraftAndroid.deleteCalendarEvent(eventId);
                        });
                    }
                },

                // Local Notifications
                notifications: {
                    schedule: function(notification) {
                        return new Promise(function(resolve, reject) {
                            window._craftNotifResolve = resolve;
                            window._craftNotifReject = reject;
                            CraftAndroid.scheduleNotification(JSON.stringify(notification));
                        });
                    },
                    cancel: function(id) {
                        CraftAndroid.cancelNotification(id);
                    },
                    cancelAll: function() {
                        CraftAndroid.cancelAllNotifications();
                    }
                },

                // In-App Purchase
                iap: {
                    getProducts: function(productIds) {
                        return new Promise(function(resolve, reject) {
                            window._craftProductsResolve = resolve;
                            window._craftProductsReject = reject;
                            CraftAndroid.getProducts(JSON.stringify(productIds));
                        });
                    },
                    purchase: function(productId) {
                        return new Promise(function(resolve, reject) {
                            window._craftPurchaseResolve = resolve;
                            window._craftPurchaseReject = reject;
                            CraftAndroid.purchase(productId);
                        });
                    },
                    restore: function() {
                        return new Promise(function(resolve, reject) {
                            window._craftRestoreResolve = resolve;
                            window._craftRestoreReject = reject;
                            CraftAndroid.restorePurchases();
                        });
                    }
                },

                // Keep Awake
                setKeepAwake: function(enabled) {
                    return CraftAndroid.setKeepAwake(enabled);
                },

                // Orientation Lock
                lockOrientation: function(orientation) {
                    return CraftAndroid.lockOrientation(orientation);
                },
                unlockOrientation: function() {
                    return CraftAndroid.unlockOrientation();
                },

                // Deep Links
                onDeepLink: function(callback) {
                    window.addEventListener('craftDeepLink', function(e) { callback(e.detail); });
                },

                // QR/Barcode Scanner
                scanQRCode: function() {
                    return new Promise(function(resolve, reject) {
                        window._craftQRResolve = resolve;
                        window._craftQRReject = reject;
                        CraftAndroid.scanQRCode();
                    });
                },

                // File Picker
                pickFile: function(types) {
                    return new Promise(function(resolve, reject) {
                        window._craftFileResolve = resolve;
                        window._craftFileReject = reject;
                        CraftAndroid.pickFile(JSON.stringify(types || []));
                    });
                },

                // File Download
                downloadFile: function(url, filename) {
                    return new Promise(function(resolve, reject) {
                        window._craftDownloadResolve = resolve;
                        window._craftDownloadReject = reject;
                        CraftAndroid.downloadFile(url, filename);
                    });
                },
                saveFile: function(data, filename) {
                    return new Promise(function(resolve, reject) {
                        window._craftSaveResolve = resolve;
                        window._craftSaveReject = reject;
                        CraftAndroid.saveFile(data, filename);
                    });
                },

                // Google Sign In
                signInWithGoogle: function() {
                    return new Promise(function(resolve, reject) {
                        window._craftGoogleResolve = resolve;
                        window._craftGoogleReject = reject;
                        CraftAndroid.signInWithGoogle();
                    });
                },

                // Audio Recording
                startAudioRecording: function() {
                    return new Promise(function(resolve, reject) {
                        window._craftAudioResolve = resolve;
                        window._craftAudioReject = reject;
                        CraftAndroid.startAudioRecording();
                    });
                },
                stopAudioRecording: function() {
                    return new Promise(function(resolve, reject) {
                        window._craftAudioStopResolve = resolve;
                        window._craftAudioStopReject = reject;
                        CraftAndroid.stopAudioRecording();
                    });
                },

                // Video Recording
                startVideoRecording: function() {
                    return new Promise(function(resolve, reject) {
                        window._craftVideoResolve = resolve;
                        window._craftVideoReject = reject;
                        CraftAndroid.startVideoRecording();
                    });
                },

                // Motion Sensors
                startMotionUpdates: function(interval) {
                    return CraftAndroid.startMotionUpdates(interval || 100);
                },
                stopMotionUpdates: function() {
                    CraftAndroid.stopMotionUpdates();
                },
                onMotionUpdate: function(callback) {
                    window.addEventListener('craftMotionUpdate', function(e) { callback(e.detail); });
                },

                // Local Database
                db: {
                    execute: function(sql, params) {
                        return new Promise(function(resolve, reject) {
                            window._craftDbExecResolve = resolve;
                            window._craftDbExecReject = reject;
                            CraftAndroid.dbExecute(sql, JSON.stringify(params || []));
                        });
                    },
                    query: function(sql, params) {
                        return new Promise(function(resolve, reject) {
                            window._craftDbQueryResolve = resolve;
                            window._craftDbQueryReject = reject;
                            CraftAndroid.dbQuery(sql, JSON.stringify(params || []));
                        });
                    }
                },

                // Bluetooth
                bluetooth: {
                    startScan: function() {
                        return new Promise(function(resolve, reject) {
                            window._craftBleResolve = resolve;
                            window._craftBleReject = reject;
                            CraftAndroid.startBluetoothScan();
                        });
                    },
                    stopScan: function() {
                        CraftAndroid.stopBluetoothScan();
                    },
                    onDevice: function(callback) {
                        window.addEventListener('craftBluetoothDevice', function(e) { callback(e.detail); });
                    }
                },

                // NFC
                scanNFC: function() {
                    return new Promise(function(resolve, reject) {
                        window._craftNfcResolve = resolve;
                        window._craftNfcReject = reject;
                        CraftAndroid.scanNFC();
                    });
                },

                // Fitness / Health
                fitness: {
                    requestAuthorization: function(types) {
                        return new Promise(function(resolve, reject) {
                            window._craftFitnessAuthResolve = resolve;
                            window._craftFitnessAuthReject = reject;
                            CraftAndroid.requestFitnessAuthorization(JSON.stringify(types || []));
                        });
                    },
                    getData: function(type, startDate, endDate) {
                        return new Promise(function(resolve, reject) {
                            window._craftFitnessDataResolve = resolve;
                            window._craftFitnessDataReject = reject;
                            CraftAndroid.getFitnessData(type, startDate || 0, endDate || 0);
                        });
                    }
                },

                // Screen Capture
                takeScreenshot: function() {
                    return new Promise(function(resolve, reject) {
                        window._craftScreenshotResolve = resolve;
                        window._craftScreenshotReject = reject;
                        CraftAndroid.takeScreenshot();
                    });
                },

                // Background Tasks
                backgroundTask: {
                    register: function(taskId) {
                        return new Promise(function(resolve, reject) {
                            window._craftBgTaskResolve = resolve;
                            window._craftBgTaskReject = reject;
                            CraftAndroid.registerBackgroundTask(taskId);
                        });
                    },
                    schedule: function(taskId, options) {
                        options = options || {};
                        return new Promise(function(resolve, reject) {
                            window._craftBgTaskResolve = resolve;
                            window._craftBgTaskReject = reject;
                            CraftAndroid.scheduleBackgroundTask(
                                taskId,
                                options.delay || 900,
                                options.requiresNetwork || false,
                                options.requiresCharging || false
                            );
                        });
                    },
                    cancel: function(taskId) {
                        return new Promise(function(resolve, reject) {
                            window._craftBgTaskResolve = resolve;
                            window._craftBgTaskReject = reject;
                            CraftAndroid.cancelBackgroundTask(taskId);
                        });
                    },
                    cancelAll: function() {
                        return new Promise(function(resolve, reject) {
                            window._craftBgTaskResolve = resolve;
                            window._craftBgTaskReject = reject;
                            CraftAndroid.cancelAllBackgroundTasks();
                        });
                    }
                },

                // PDF Viewer
                openPDF: function(source, page) {
                    return new Promise(function(resolve, reject) {
                        window._craftPDFResolve = resolve;
                        window._craftPDFReject = reject;
                        CraftAndroid.openPDF(source, page || 0);
                    });
                },
                closePDF: function() {
                    return new Promise(function(resolve, reject) {
                        window._craftPDFResolve = resolve;
                        window._craftPDFReject = reject;
                        CraftAndroid.closePDF();
                    });
                },

                // Contacts Picker
                pickContact: function(options) {
                    options = options || {};
                    return new Promise(function(resolve, reject) {
                        window._craftPickContactResolve = resolve;
                        window._craftPickContactReject = reject;
                        CraftAndroid.pickContact(options.multiple || false);
                    });
                },

                // App Shortcuts
                shortcuts: {
                    set: function(shortcuts) {
                        return new Promise(function(resolve, reject) {
                            window._craftShortcutsResolve = resolve;
                            window._craftShortcutsReject = reject;
                            CraftAndroid.setShortcuts(JSON.stringify(shortcuts));
                        });
                    },
                    clear: function() {
                        return new Promise(function(resolve, reject) {
                            window._craftShortcutsResolve = resolve;
                            window._craftShortcutsReject = reject;
                            CraftAndroid.clearShortcuts();
                        });
                    },
                    onShortcut: function(callback) {
                        window.addEventListener('craftShortcut', function(e) { callback(e.detail); });
                    }
                },

                // Shared Preferences (Android equivalent of Keychain Sharing)
                sharedKeychain: {
                    set: function(key, value, group) {
                        return new Promise(function(resolve, reject) {
                            window._craftSharedKeychainResolve = resolve;
                            window._craftSharedKeychainReject = reject;
                            CraftAndroid.setSharedItem(key, value, group || '');
                        });
                    },
                    get: function(key, group) {
                        return new Promise(function(resolve, reject) {
                            window._craftSharedKeychainResolve = resolve;
                            window._craftSharedKeychainReject = reject;
                            CraftAndroid.getSharedItem(key, group || '');
                        });
                    },
                    remove: function(key, group) {
                        return new Promise(function(resolve, reject) {
                            window._craftSharedKeychainResolve = resolve;
                            window._craftSharedKeychainReject = reject;
                            CraftAndroid.removeSharedItem(key, group || '');
                        });
                    }
                },

                // Local Auth Persistence
                authPersistence: {
                    enable: function(duration) {
                        return new Promise(function(resolve, reject) {
                            window._craftAuthPersistResolve = resolve;
                            window._craftAuthPersistReject = reject;
                            CraftAndroid.setAuthPersistence(true, duration || 300);
                        });
                    },
                    disable: function() {
                        return new Promise(function(resolve, reject) {
                            window._craftAuthPersistResolve = resolve;
                            window._craftAuthPersistReject = reject;
                            CraftAndroid.setAuthPersistence(false, 0);
                        });
                    },
                    check: function() {
                        return new Promise(function(resolve, reject) {
                            window._craftAuthPersistResolve = resolve;
                            window._craftAuthPersistReject = reject;
                            CraftAndroid.checkAuthPersistence();
                        });
                    },
                    clear: function() {
                        return new Promise(function(resolve, reject) {
                            window._craftAuthPersistResolve = resolve;
                            window._craftAuthPersistReject = reject;
                            CraftAndroid.clearAuthPersistence();
                        });
                    }
                },

                // AR (ARCore) - Note: Full ARCore requires native Activity integration
                ar: {
                    start: function(options) {
                        return new Promise(function(resolve, reject) {
                            window._craftARResolve = resolve;
                            window._craftARReject = reject;
                            CraftAndroid.startAR(JSON.stringify(options || {}));
                        });
                    },
                    stop: function() {
                        return new Promise(function(resolve, reject) {
                            window._craftARResolve = resolve;
                            window._craftARReject = reject;
                            CraftAndroid.stopAR();
                        });
                    },
                    placeObject: function(model, position) {
                        return new Promise(function(resolve, reject) {
                            window._craftARResolve = resolve;
                            window._craftARReject = reject;
                            CraftAndroid.placeARObject(model, JSON.stringify(position || {}));
                        });
                    },
                    removeObject: function(objectId) {
                        return new Promise(function(resolve, reject) {
                            window._craftARResolve = resolve;
                            window._craftARReject = reject;
                            CraftAndroid.removeARObject(objectId);
                        });
                    },
                    getPlanes: function() {
                        return new Promise(function(resolve, reject) {
                            window._craftARResolve = resolve;
                            window._craftARReject = reject;
                            CraftAndroid.getARPlanes();
                        });
                    },
                    onPlaneDetected: function(callback) {
                        window.addEventListener('craftARPlane', function(e) { callback(e.detail); });
                    }
                },

                // ML (ML Kit)
                ml: {
                    classifyImage: function(imageBase64) {
                        return new Promise(function(resolve, reject) {
                            window._craftMLResolve = resolve;
                            window._craftMLReject = reject;
                            CraftAndroid.classifyImage(imageBase64);
                        });
                    },
                    detectObjects: function(imageBase64) {
                        return new Promise(function(resolve, reject) {
                            window._craftMLResolve = resolve;
                            window._craftMLReject = reject;
                            CraftAndroid.detectObjects(imageBase64);
                        });
                    },
                    recognizeText: function(imageBase64) {
                        return new Promise(function(resolve, reject) {
                            window._craftMLResolve = resolve;
                            window._craftMLReject = reject;
                            CraftAndroid.recognizeText(imageBase64);
                        });
                    }
                },

                // Deep Links
                deepLinks: {
                    getInitialURL: function() {
                        return new Promise(function(resolve, reject) {
                            window._craftDeepLinkResolve = resolve;
                            window._craftDeepLinkReject = reject;
                            CraftAndroid.getInitialURL();
                        });
                    },
                    onLink: function(callback) {
                        window.addEventListener('craftDeepLink', function(e) { callback(e.detail); });
                    }
                },

                // Logging
                log: function(msg) {
                    CraftAndroid.log(msg);
                },

                // Performance Profiling
                _profiling: false,
                _profilingData: null,
                _profilingCallTimings: [],

                startProfiling: function() {
                    var self = this;
                    this._profiling = true;
                    this._profilingData = {
                        startTime: Date.now(),
                        startMemory: null,
                        callTimings: [],
                        bridgeCalls: 0
                    };
                    this._profilingCallTimings = [];
                    // Get memory info
                    var memInfo = CraftAndroid.getMemoryUsage();
                    try { this._profilingData.startMemory = JSON.parse(memInfo); } catch(e) {}
                    console.log('[Craft] Profiling started');
                    return { started: true, timestamp: this._profilingData.startTime };
                },

                stopProfiling: function() {
                    if (!this._profiling || !this._profilingData) {
                        return null;
                    }
                    this._profiling = false;
                    var memInfo = null;
                    try { memInfo = JSON.parse(CraftAndroid.getMemoryUsage()); } catch(e) {}
                    var report = {
                        duration: Date.now() - this._profilingData.startTime,
                        bridgeCalls: this._profilingCallTimings.length,
                        callTimings: this._profilingCallTimings,
                        memory: {
                            start: this._profilingData.startMemory,
                            end: memInfo
                        },
                        avgCallTime: this._profilingCallTimings.length > 0
                            ? this._profilingCallTimings.reduce(function(a, b) { return a + b.duration; }, 0) / this._profilingCallTimings.length
                            : 0
                    };
                    this._profilingData = null;
                    console.log('[Craft] Profiling stopped', report);
                    return report;
                },

                _recordCallTiming: function(action, startTime, endTime) {
                    if (this._profiling) {
                        this._profilingCallTimings.push({
                            action: action,
                            startTime: startTime,
                            endTime: endTime,
                            duration: endTime - startTime
                        });
                    }
                },

                getProfilingData: function() {
                    if (!this._profilingData) return null;
                    return {
                        running: this._profiling,
                        duration: Date.now() - this._profilingData.startTime,
                        bridgeCalls: this._profilingCallTimings.length,
                        callTimings: this._profilingCallTimings
                    };
                },

                // OTA Updates
                ota: {
                    _config: null,
                    _status: 'idle',
                    _progressCallbacks: [],
                    _statusCallbacks: [],

                    configure: function(options) {
                        this._config = options;
                        CraftAndroid.otaConfigure(JSON.stringify(options));
                    },
                    checkForUpdate: function() {
                        return new Promise(function(resolve, reject) {
                            window._craftOTACheckResolve = resolve;
                            window._craftOTACheckReject = reject;
                            CraftAndroid.otaCheckForUpdate();
                        });
                    },
                    downloadUpdate: function(options) {
                        return new Promise(function(resolve, reject) {
                            window._craftOTADownloadResolve = resolve;
                            window._craftOTADownloadReject = reject;
                            CraftAndroid.otaDownloadUpdate(JSON.stringify(options || {}));
                        });
                    },
                    applyUpdate: function() {
                        return new Promise(function(resolve, reject) {
                            window._craftOTAApplyResolve = resolve;
                            window._craftOTAApplyReject = reject;
                            CraftAndroid.otaApplyUpdate();
                        });
                    },
                    rollback: function() {
                        return new Promise(function(resolve, reject) {
                            window._craftOTARollbackResolve = resolve;
                            window._craftOTARollbackReject = reject;
                            CraftAndroid.otaRollback();
                        });
                    },
                    getCurrentBundle: function() {
                        var bundleJson = CraftAndroid.otaGetCurrentBundle();
                        try { return JSON.parse(bundleJson); }
                        catch(e) { return { version: '1.0.0', buildNumber: 1, hash: '', isOriginal: true, installedAt: '' }; }
                    },
                    onProgress: function(callback) {
                        this._progressCallbacks.push(callback);
                        window.addEventListener('craftOTAProgress', function(e) { callback(e.detail); });
                    },
                    onStatusChange: function(callback) {
                        this._statusCallbacks.push(callback);
                        window.addEventListener('craftOTAStatus', function(e) { callback(e.detail.status); });
                    }
                },

                // Debug Mode
                _debug: false,
                _lastError: null,
                _errorHistory: [],
                _callLog: [],
                _networkLog: [],
                _consoleLog: [],
                _originalConsole: null,

                // Error code mappings for user-friendly messages
                _errorMessages: {
                    'PERMISSION_DENIED': 'Permission was denied. Please grant access in Settings.',
                    'NOT_AVAILABLE': 'This feature is not available on this device.',
                    'CANCELLED': 'The operation was cancelled by the user.',
                    'NETWORK_ERROR': 'A network error occurred. Please check your connection.',
                    'TIMEOUT': 'The operation timed out. Please try again.',
                    'INVALID_PARAMS': 'Invalid parameters provided.',
                    'NOT_FOUND': 'The requested resource was not found.',
                    'AUTH_FAILED': 'Authentication failed.',
                    'STORAGE_FULL': 'Storage is full. Please free up space.',
                    'CRAFT_ERROR': 'An unexpected error occurred.'
                },

                // Get user-friendly error message
                getErrorMessage: function(code) {
                    return this._errorMessages[code] || this._errorMessages['CRAFT_ERROR'];
                },

                // Store error for debugging
                _storeError: function(error, code, nativeStack) {
                    this._lastError = {
                        message: error,
                        code: code || 'CRAFT_ERROR',
                        timestamp: Date.now(),
                        nativeStack: nativeStack || null,
                        jsStack: new Error().stack
                    };
                    if (this._debug) {
                        window.dispatchEvent(new CustomEvent('craftError', {detail: this._lastError}));
                        console.error('[Craft Error]', code, error);
                    }
                    this._errorHistory.push(this._lastError);
                    if (this._errorHistory.length > 50) this._errorHistory.shift();
                },

                // Get error history
                getErrorHistory: function() {
                    return this._errorHistory.slice();
                },

                // Clear error history
                clearErrorHistory: function() {
                    this._errorHistory = [];
                    this._lastError = null;
                },

                // Get last error details
                getLastError: function() {
                    return this._lastError;
                },

                // Enable/disable debug mode
                setDebugMode: function(enabled) {
                    this._debug = enabled;
                    if (enabled) {
                        this._callLog = [];
                        this._networkLog = [];
                        this._setupConsoleCapture();
                        this._setupNetworkInspector();
                        console.log('[Craft] Debug mode enabled');
                    } else {
                        this._restoreConsole();
                    }
                },

                // Setup console capture
                _setupConsoleCapture: function() {
                    if (this._originalConsole) return;
                    var self = this;
                    this._originalConsole = {
                        log: console.log,
                        warn: console.warn,
                        error: console.error,
                        info: console.info,
                        debug: console.debug
                    };
                    ['log', 'warn', 'error', 'info', 'debug'].forEach(function(level) {
                        console[level] = function() {
                            var args = Array.prototype.slice.call(arguments);
                            self._consoleLog.push({
                                level: level,
                                args: args.map(function(a) {
                                    try { return typeof a === 'object' ? JSON.stringify(a) : String(a); }
                                    catch(e) { return String(a); }
                                }),
                                timestamp: Date.now()
                            });
                            if (self._consoleLog.length > 200) self._consoleLog.shift();
                            self._originalConsole[level].apply(console, arguments);
                        };
                    });
                },

                // Restore original console
                _restoreConsole: function() {
                    if (!this._originalConsole) return;
                    console.log = this._originalConsole.log;
                    console.warn = this._originalConsole.warn;
                    console.error = this._originalConsole.error;
                    console.info = this._originalConsole.info;
                    console.debug = this._originalConsole.debug;
                    this._originalConsole = null;
                },

                // Setup network inspector
                _setupNetworkInspector: function() {
                    var self = this;
                    if (window._craftNetworkSetup) return;
                    window._craftNetworkSetup = true;

                    var originalFetch = window.fetch;
                    window.fetch = function(url, options) {
                        var startTime = Date.now();
                        var entry = {
                            type: 'fetch',
                            url: typeof url === 'string' ? url : url.url,
                            method: (options && options.method) || 'GET',
                            startTime: startTime,
                            status: null,
                            duration: null
                        };
                        self._networkLog.push(entry);
                        if (self._networkLog.length > 100) self._networkLog.shift();

                        return originalFetch.apply(window, arguments).then(function(response) {
                            entry.status = response.status;
                            entry.duration = Date.now() - startTime;
                            return response;
                        }).catch(function(err) {
                            entry.status = 'error';
                            entry.error = err.message;
                            entry.duration = Date.now() - startTime;
                            throw err;
                        });
                    };

                    var OriginalXHR = window.XMLHttpRequest;
                    window.XMLHttpRequest = function() {
                        var xhr = new OriginalXHR();
                        var entry = { type: 'xhr', url: '', method: '', startTime: null, status: null, duration: null };

                        var originalOpen = xhr.open;
                        xhr.open = function(method, url) {
                            entry.method = method;
                            entry.url = url;
                            return originalOpen.apply(xhr, arguments);
                        };

                        var originalSend = xhr.send;
                        xhr.send = function() {
                            entry.startTime = Date.now();
                            self._networkLog.push(entry);
                            if (self._networkLog.length > 100) self._networkLog.shift();

                            xhr.addEventListener('loadend', function() {
                                entry.status = xhr.status;
                                entry.duration = Date.now() - entry.startTime;
                            });
                            return originalSend.apply(xhr, arguments);
                        };
                        return xhr;
                    };
                },

                // Get console log
                getConsoleLog: function() {
                    return this._consoleLog.slice();
                },

                // Clear console log
                clearConsoleLog: function() {
                    this._consoleLog = [];
                },

                // Get network log
                getNetworkLog: function() {
                    return this._networkLog.slice();
                },

                // Clear network log
                clearNetworkLog: function() {
                    this._networkLog = [];
                },

                // Get call log
                getCallLog: function() {
                    return this._callLog;
                },

                // Clear call log
                clearCallLog: function() {
                    this._callLog = [];
                },

                // Internal: log bridge call
                _logCall: function(action, params) {
                    if (this._debug) {
                        var entry = {
                            action: action,
                            params: params,
                            timestamp: Date.now()
                        };
                        this._callLog.push(entry);
                        if (this._callLog.length > 100) this._callLog.shift();
                        console.log('[Craft] ' + action, params);
                    }
                },

                // Get full debug report
                getDebugReport: function() {
                    return {
                        enabled: this._debug,
                        lastError: this._lastError,
                        errorHistory: this._errorHistory.slice(-10),
                        callLog: this._callLog.slice(-20),
                        networkLog: this._networkLog.slice(-20),
                        consoleLog: this._consoleLog.slice(-50),
                        timestamp: Date.now()
                    };
                }
            };

            // Dispatch ready event
            window.dispatchEvent(new CustomEvent('craftReady', {detail: window.craft}));
            console.log('Craft Android bridge initialized');
        """.trimIndent()

        activity.runOnUiThread {
            webView.evaluateJavascript(script, null)
        }
    }

    // ==================== Haptics ====================

    @JavascriptInterface
    fun haptic(style: String) {
        val vibrator = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            val vibratorManager = activity.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager
            vibratorManager.defaultVibrator
        } else {
            @Suppress("DEPRECATION")
            activity.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator
        }

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val effect = when (style) {
                "light" -> VibrationEffect.createOneShot(10, VibrationEffect.DEFAULT_AMPLITUDE)
                "medium" -> VibrationEffect.createOneShot(20, VibrationEffect.DEFAULT_AMPLITUDE)
                "heavy" -> VibrationEffect.createOneShot(50, VibrationEffect.DEFAULT_AMPLITUDE)
                "success" -> VibrationEffect.createWaveform(longArrayOf(0, 30, 50, 30), -1)
                "warning" -> VibrationEffect.createWaveform(longArrayOf(0, 50, 100, 50), -1)
                "error" -> VibrationEffect.createWaveform(longArrayOf(0, 100, 50, 100), -1)
                "selection" -> VibrationEffect.createOneShot(5, VibrationEffect.DEFAULT_AMPLITUDE)
                else -> VibrationEffect.createOneShot(20, VibrationEffect.DEFAULT_AMPLITUDE)
            }
            vibrator.vibrate(effect)
        } else {
            @Suppress("DEPRECATION")
            vibrator.vibrate(20)
        }
    }

    // ==================== Speech Recognition ====================

    @JavascriptInterface
    fun startListening() {
        if (!SpeechRecognizer.isRecognitionAvailable(activity)) {
            sendEvent("craftSpeechError", mapOf("error" to "Speech recognition not available"))
            return
        }

        activity.runOnUiThread {
            if (ContextCompat.checkSelfPermission(activity, Manifest.permission.RECORD_AUDIO)
                != PackageManager.PERMISSION_GRANTED) {
                ActivityCompat.requestPermissions(activity, arrayOf(Manifest.permission.RECORD_AUDIO), 100)
                return@runOnUiThread
            }

            speechRecognizer = SpeechRecognizer.createSpeechRecognizer(activity)
            speechRecognizer?.setRecognitionListener(object : RecognitionListener {
                override fun onReadyForSpeech(params: Bundle?) {
                    isListening = true
                    sendEvent("craftSpeechStart", emptyMap())
                    haptic("light")
                }

                override fun onBeginningOfSpeech() {}
                override fun onRmsChanged(rmsdB: Float) {}
                override fun onBufferReceived(buffer: ByteArray?) {}
                override fun onEndOfSpeech() {}

                override fun onError(error: Int) {
                    isListening = false
                    val errorMsg = when (error) {
                        SpeechRecognizer.ERROR_AUDIO -> "Audio recording error"
                        SpeechRecognizer.ERROR_CLIENT -> "Client error"
                        SpeechRecognizer.ERROR_INSUFFICIENT_PERMISSIONS -> "Insufficient permissions"
                        SpeechRecognizer.ERROR_NETWORK -> "Network error"
                        SpeechRecognizer.ERROR_NETWORK_TIMEOUT -> "Network timeout"
                        SpeechRecognizer.ERROR_NO_MATCH -> "No match"
                        SpeechRecognizer.ERROR_RECOGNIZER_BUSY -> "Recognizer busy"
                        SpeechRecognizer.ERROR_SERVER -> "Server error"
                        SpeechRecognizer.ERROR_SPEECH_TIMEOUT -> "Speech timeout"
                        else -> "Unknown error"
                    }
                    sendEvent("craftSpeechError", mapOf("error" to errorMsg))
                    haptic("light")
                }

                override fun onResults(results: Bundle?) {
                    isListening = false
                    val matches = results?.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION)
                    val transcript = matches?.firstOrNull() ?: ""
                    sendEvent("craftSpeechResult", mapOf("transcript" to transcript, "isFinal" to true))
                    sendEvent("craftSpeechEnd", emptyMap())
                    haptic("light")
                }

                override fun onPartialResults(partialResults: Bundle?) {
                    val matches = partialResults?.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION)
                    val transcript = matches?.firstOrNull() ?: ""
                    sendEvent("craftSpeechResult", mapOf("transcript" to transcript, "isFinal" to false))
                }

                override fun onEvent(eventType: Int, params: Bundle?) {}
            })

            val intent = Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH).apply {
                putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM)
                putExtra(RecognizerIntent.EXTRA_LANGUAGE, Locale.getDefault())
                putExtra(RecognizerIntent.EXTRA_PARTIAL_RESULTS, true)
                putExtra(RecognizerIntent.EXTRA_MAX_RESULTS, 1)
            }

            speechRecognizer?.startListening(intent)
        }
    }

    @JavascriptInterface
    fun stopListening() {
        activity.runOnUiThread {
            speechRecognizer?.stopListening()
            speechRecognizer?.destroy()
            speechRecognizer = null
            isListening = false
        }
    }

    // ==================== Share ====================

    @JavascriptInterface
    fun share(text: String, title: String) {
        val intent = Intent(Intent.ACTION_SEND).apply {
            type = "text/plain"
            putExtra(Intent.EXTRA_TEXT, text)
            if (title.isNotEmpty()) {
                putExtra(Intent.EXTRA_SUBJECT, title)
            }
        }
        activity.startActivity(Intent.createChooser(intent, "Share"))
    }

    // ==================== Camera & Gallery ====================

    @JavascriptInterface
    fun openCamera() {
        if (ContextCompat.checkSelfPermission(activity, Manifest.permission.CAMERA)
            != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(activity, arrayOf(Manifest.permission.CAMERA), 101)
            return
        }

        val intent = Intent(MediaStore.ACTION_IMAGE_CAPTURE)
        activity.startActivityForResult(intent, REQUEST_CAMERA)
    }

    @JavascriptInterface
    fun pickImage() {
        val intent = Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI)
        activity.startActivityForResult(intent, REQUEST_GALLERY)
    }

    fun handleImageResult(requestCode: Int, resultCode: Int, data: Intent?) {
        if (resultCode != Activity.RESULT_OK) {
            val event = if (requestCode == REQUEST_CAMERA) "_craftCameraReject" else "_craftGalleryReject"
            activity.runOnUiThread {
                webView.evaluateJavascript("window.$event && window.$event('Cancelled')", null)
            }
            return
        }

        val imageUri: String? = when (requestCode) {
            REQUEST_CAMERA -> {
                // For camera, we get a bitmap thumbnail
                val bitmap = data?.extras?.get("data") as? Bitmap
                bitmap?.let { "data:image/png;base64,${bitmapToBase64(it)}" }
            }
            REQUEST_GALLERY -> {
                data?.data?.toString()
            }
            else -> null
        }

        val event = if (requestCode == REQUEST_CAMERA) "_craftCameraResolve" else "_craftGalleryResolve"
        activity.runOnUiThread {
            webView.evaluateJavascript("window.$event && window.$event('$imageUri')", null)
        }
    }

    private fun bitmapToBase64(bitmap: Bitmap): String {
        val outputStream = java.io.ByteArrayOutputStream()
        bitmap.compress(Bitmap.CompressFormat.PNG, 100, outputStream)
        return android.util.Base64.encodeToString(outputStream.toByteArray(), android.util.Base64.NO_WRAP)
    }

    // ==================== Biometric Auth ====================

    private fun isBiometricAvailable(): Boolean {
        val biometricManager = BiometricManager.from(activity)
        return biometricManager.canAuthenticate(BiometricManager.Authenticators.BIOMETRIC_STRONG) ==
                BiometricManager.BIOMETRIC_SUCCESS
    }

    @JavascriptInterface
    fun authenticate(reason: String) {
        if (activity !is FragmentActivity) {
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftBiometricReject && window._craftBiometricReject('Activity not supported')",
                    null
                )
            }
            return
        }

        activity.runOnUiThread {
            val promptInfo = BiometricPrompt.PromptInfo.Builder()
                .setTitle("Authenticate")
                .setSubtitle(reason)
                .setNegativeButtonText("Cancel")
                .setAllowedAuthenticators(BiometricManager.Authenticators.BIOMETRIC_STRONG)
                .build()

            val biometricPrompt = BiometricPrompt(
                activity as FragmentActivity,
                mainExecutor,
                object : BiometricPrompt.AuthenticationCallback() {
                    override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {
                        webView.evaluateJavascript(
                            "window._craftBiometricResolve && window._craftBiometricResolve(true)",
                            null
                        )
                    }

                    override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {
                        webView.evaluateJavascript(
                            "window._craftBiometricReject && window._craftBiometricReject('$errString')",
                            null
                        )
                    }

                    override fun onAuthenticationFailed() {
                        // Don't reject yet - user can retry
                    }
                }
            )

            biometricPrompt.authenticate(promptInfo)
        }
    }

    // ==================== Push Notifications ====================

    @JavascriptInterface
    fun registerPush() {
        // This would integrate with Firebase Cloud Messaging
        // For now, return a placeholder token
        activity.runOnUiThread {
            // In a real implementation, you would use Firebase:
            // FirebaseMessaging.getInstance().token.addOnCompleteListener { task ->
            //     if (task.isSuccessful) {
            //         val token = task.result
            //         webView.evaluateJavascript("window._craftPushResolve('$token')", null)
            //     } else {
            //         webView.evaluateJavascript("window._craftPushReject('Failed to get token')", null)
            //     }
            // }

            webView.evaluateJavascript(
                "window._craftPushResolve && window._craftPushResolve('push-token-placeholder')",
                null
            )
        }
    }

    // ==================== Secure Storage ====================

    @JavascriptInterface
    fun secureSet(key: String, value: String): Boolean {
        return try {
            securePrefs.edit().putString(key, value).apply()
            true
        } catch (e: Exception) {
            false
        }
    }

    @JavascriptInterface
    fun secureGet(key: String): String? {
        return try {
            securePrefs.getString(key, null)
        } catch (e: Exception) {
            null
        }
    }

    @JavascriptInterface
    fun secureRemove(key: String): Boolean {
        return try {
            securePrefs.edit().remove(key).apply()
            true
        } catch (e: Exception) {
            false
        }
    }

    // ==================== Logging ====================

    @JavascriptInterface
    fun log(message: String) {
        android.util.Log.d("CraftBridge", message)
    }

    // ==================== Geolocation ====================

    @JavascriptInterface
    fun getCurrentPosition(optionsJson: String) {
        if (ContextCompat.checkSelfPermission(activity, Manifest.permission.ACCESS_FINE_LOCATION)
            != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(
                activity,
                arrayOf(Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION),
                REQUEST_LOCATION
            )
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftLocationReject && window._craftLocationReject({code: 1, message: 'Permission denied'})",
                    null
                )
            }
            return
        }

        fusedLocationClient = LocationServices.getFusedLocationProviderClient(activity)
        fusedLocationClient?.lastLocation?.addOnSuccessListener { location: Location? ->
            if (location != null) {
                val json = JSONObject().apply {
                    put("latitude", location.latitude)
                    put("longitude", location.longitude)
                    put("accuracy", location.accuracy)
                    put("altitude", location.altitude)
                    put("speed", location.speed)
                    put("heading", location.bearing)
                    put("timestamp", location.time)
                }
                activity.runOnUiThread {
                    webView.evaluateJavascript(
                        "window._craftLocationResolve && window._craftLocationResolve($json)",
                        null
                    )
                }
            } else {
                // Request fresh location if last location is null
                requestFreshLocation()
            }
        }?.addOnFailureListener { e ->
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftLocationReject && window._craftLocationReject({code: 2, message: '${e.message}'})",
                    null
                )
            }
        }
    }

    private fun requestFreshLocation() {
        if (ActivityCompat.checkSelfPermission(activity, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
            return
        }

        val locationRequest = LocationRequest.Builder(Priority.PRIORITY_HIGH_ACCURACY, 1000)
            .setWaitForAccurateLocation(false)
            .setMinUpdateIntervalMillis(500)
            .setMaxUpdateDelayMillis(1000)
            .setMaxUpdates(1)
            .build()

        val callback = object : LocationCallback() {
            override fun onLocationResult(result: LocationResult) {
                fusedLocationClient?.removeLocationUpdates(this)
                val location = result.lastLocation
                if (location != null) {
                    val json = JSONObject().apply {
                        put("latitude", location.latitude)
                        put("longitude", location.longitude)
                        put("accuracy", location.accuracy)
                        put("altitude", location.altitude)
                        put("speed", location.speed)
                        put("heading", location.bearing)
                        put("timestamp", location.time)
                    }
                    activity.runOnUiThread {
                        webView.evaluateJavascript(
                            "window._craftLocationResolve && window._craftLocationResolve($json)",
                            null
                        )
                    }
                }
            }
        }

        fusedLocationClient?.requestLocationUpdates(locationRequest, callback, Looper.getMainLooper())
    }

    @JavascriptInterface
    fun watchPosition(optionsJson: String): Int {
        if (ContextCompat.checkSelfPermission(activity, Manifest.permission.ACCESS_FINE_LOCATION)
            != PackageManager.PERMISSION_GRANTED) {
            return -1
        }

        val currentWatchId = ++watchId
        fusedLocationClient = LocationServices.getFusedLocationProviderClient(activity)

        val locationRequest = LocationRequest.Builder(Priority.PRIORITY_HIGH_ACCURACY, 5000)
            .setMinUpdateIntervalMillis(2000)
            .build()

        locationCallback = object : LocationCallback() {
            override fun onLocationResult(result: LocationResult) {
                val location = result.lastLocation ?: return
                val json = JSONObject().apply {
                    put("latitude", location.latitude)
                    put("longitude", location.longitude)
                    put("accuracy", location.accuracy)
                    put("altitude", location.altitude)
                    put("speed", location.speed)
                    put("heading", location.bearing)
                    put("timestamp", location.time)
                }
                activity.runOnUiThread {
                    webView.evaluateJavascript(
                        "window._craftLocationWatch_$currentWatchId && window._craftLocationWatch_$currentWatchId($json)",
                        null
                    )
                }
            }
        }

        if (ActivityCompat.checkSelfPermission(activity, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {
            fusedLocationClient?.requestLocationUpdates(locationRequest, locationCallback!!, Looper.getMainLooper())
        }

        return currentWatchId
    }

    @JavascriptInterface
    fun clearWatch(watchId: Int) {
        locationCallback?.let {
            fusedLocationClient?.removeLocationUpdates(it)
        }
        locationCallback = null
    }

    // ==================== Clipboard ====================

    @JavascriptInterface
    fun clipboardRead(): String {
        val clipboard = activity.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
        val clip = clipboard.primaryClip
        return if (clip != null && clip.itemCount > 0) {
            clip.getItemAt(0).text?.toString() ?: ""
        } else {
            ""
        }
    }

    @JavascriptInterface
    fun clipboardWrite(text: String): Boolean {
        return try {
            val clipboard = activity.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
            val clip = ClipData.newPlainText("Craft", text)
            clipboard.setPrimaryClip(clip)
            true
        } catch (e: Exception) {
            false
        }
    }

    // ==================== Device Info ====================

    @JavascriptInterface
    fun getDeviceInfo(): String {
        val metrics = DisplayMetrics()
        @Suppress("DEPRECATION")
        activity.windowManager.defaultDisplay.getMetrics(metrics)

        return JSONObject().apply {
            put("model", Build.MODEL)
            put("manufacturer", Build.MANUFACTURER)
            put("brand", Build.BRAND)
            put("device", Build.DEVICE)
            put("systemVersion", Build.VERSION.RELEASE)
            put("sdkVersion", Build.VERSION.SDK_INT)
            put("screenWidth", metrics.widthPixels)
            put("screenHeight", metrics.heightPixels)
            put("density", metrics.density)
            put("platform", "android")
            put("appVersion", try {
                activity.packageManager.getPackageInfo(activity.packageName, 0).versionName
            } catch (e: Exception) { "unknown" })
            put("appBuild", try {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                    activity.packageManager.getPackageInfo(activity.packageName, 0).longVersionCode
                } else {
                    @Suppress("DEPRECATION")
                    activity.packageManager.getPackageInfo(activity.packageName, 0).versionCode
                }
            } catch (e: Exception) { 0 })
            put("isEmulator", Build.FINGERPRINT.contains("generic") || Build.FINGERPRINT.contains("emulator"))
        }.toString()
    }

    // ==================== App Badge ====================

    @JavascriptInterface
    fun setBadge(count: Int) {
        // Android doesn't have native badge support, but we can use notification channels
        // This is a simplified implementation - for full support, use ShortcutBadger library
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                val notificationManager = NotificationManagerCompat.from(activity)
                // Badge is typically shown via notification count
                // Full implementation would require creating a notification
            }
        } catch (e: Exception) {
            log("Badge not supported: ${e.message}")
        }
    }

    @JavascriptInterface
    fun clearBadge() {
        setBadge(0)
    }

    // ==================== Network Status ====================

    @JavascriptInterface
    fun getNetworkStatus(): String {
        val connectivityManager = activity.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        val network = connectivityManager.activeNetwork
        val capabilities = connectivityManager.getNetworkCapabilities(network)

        val isConnected = capabilities != null
        val connectionType = when {
            capabilities?.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) == true -> "wifi"
            capabilities?.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR) == true -> "cellular"
            capabilities?.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET) == true -> "ethernet"
            else -> "none"
        }

        return JSONObject().apply {
            put("isConnected", isConnected)
            put("type", connectionType)
            put("isWifi", connectionType == "wifi")
            put("isCellular", connectionType == "cellular")
        }.toString()
    }

    @JavascriptInterface
    fun startNetworkMonitoring() {
        val connectivityManager = activity.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager

        networkCallback = object : ConnectivityManager.NetworkCallback() {
            override fun onAvailable(network: Network) {
                sendNetworkChange()
            }

            override fun onLost(network: Network) {
                sendNetworkChange()
            }

            override fun onCapabilitiesChanged(network: Network, networkCapabilities: NetworkCapabilities) {
                sendNetworkChange()
            }
        }

        val request = NetworkRequest.Builder()
            .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
            .build()

        connectivityManager.registerNetworkCallback(request, networkCallback!!)
    }

    @JavascriptInterface
    fun stopNetworkMonitoring() {
        val connectivityManager = activity.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        networkCallback?.let {
            connectivityManager.unregisterNetworkCallback(it)
        }
        networkCallback = null
    }

    private fun sendNetworkChange() {
        val status = getNetworkStatus()
        activity.runOnUiThread {
            webView.evaluateJavascript(
                "window._craftNetworkChangeCallback && window._craftNetworkChangeCallback($status)",
                null
            )
        }
    }

    // ==================== App Review ====================

    @JavascriptInterface
    fun requestReview() {
        val reviewManager = ReviewManagerFactory.create(activity)
        val request = reviewManager.requestReviewFlow()

        request.addOnCompleteListener { task ->
            if (task.isSuccessful) {
                val reviewInfo = task.result
                val flow = reviewManager.launchReviewFlow(activity, reviewInfo)
                flow.addOnCompleteListener {
                    activity.runOnUiThread {
                        webView.evaluateJavascript(
                            "window._craftReviewResolve && window._craftReviewResolve(true)",
                            null
                        )
                    }
                }
            } else {
                activity.runOnUiThread {
                    webView.evaluateJavascript(
                        "window._craftReviewReject && window._craftReviewReject('${task.exception?.message ?: \"Review flow failed\"}')",
                        null
                    )
                }
            }
        }
    }

    // ==================== Flashlight ====================

    private fun hasFlashlight(): Boolean {
        return activity.packageManager.hasSystemFeature(PackageManager.FEATURE_CAMERA_FLASH)
    }

    @JavascriptInterface
    fun setFlashlight(on: Boolean): Boolean {
        return try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                val cameraManager = activity.getSystemService(Context.CAMERA_SERVICE) as CameraManager
                val cameraId = cameraManager.cameraIdList.firstOrNull { id ->
                    cameraManager.getCameraCharacteristics(id)
                        .get(CameraCharacteristics.FLASH_INFO_AVAILABLE) == true
                }
                if (cameraId != null) {
                    cameraManager.setTorchMode(cameraId, on)
                    isFlashlightOn = on
                    true
                } else {
                    false
                }
            } else {
                false
            }
        } catch (e: CameraAccessException) {
            false
        }
    }

    @JavascriptInterface
    fun toggleFlashlight(): Boolean {
        isFlashlightOn = !isFlashlightOn
        return setFlashlight(isFlashlightOn)
    }

    // ==================== Open URL ====================

    @JavascriptInterface
    fun openURL(url: String): Boolean {
        return try {
            val intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))
            activity.startActivity(intent)
            true
        } catch (e: Exception) {
            false
        }
    }

    // ==================== Vibration Pattern ====================

    @JavascriptInterface
    fun vibrate(patternJson: String) {
        val vibrator = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            val vibratorManager = activity.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager
            vibratorManager.defaultVibrator
        } else {
            @Suppress("DEPRECATION")
            activity.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator
        }

        try {
            val pattern = org.json.JSONArray(patternJson)
            val timings = LongArray(pattern.length()) { i -> pattern.getLong(i) }

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                val effect = VibrationEffect.createWaveform(timings, -1)
                vibrator.vibrate(effect)
            } else {
                @Suppress("DEPRECATION")
                vibrator.vibrate(timings, -1)
            }
        } catch (e: Exception) {
            log("Vibration error: ${e.message}")
        }
    }

    // ==================== App State ====================

    @JavascriptInterface
    fun getAppState(): String {
        return currentAppState
    }

    @JavascriptInterface
    fun startAppStateMonitoring() {
        activity.runOnUiThread {
            ProcessLifecycleOwner.get().lifecycle.addObserver(appStateObserver)
        }
    }

    @JavascriptInterface
    fun stopAppStateMonitoring() {
        activity.runOnUiThread {
            ProcessLifecycleOwner.get().lifecycle.removeObserver(appStateObserver)
        }
    }

    private val appStateObserver = LifecycleEventObserver { _, event ->
        val newState = when (event) {
            Lifecycle.Event.ON_START, Lifecycle.Event.ON_RESUME -> "active"
            Lifecycle.Event.ON_PAUSE -> "inactive"
            Lifecycle.Event.ON_STOP -> "background"
            else -> currentAppState
        }

        if (newState != currentAppState) {
            currentAppState = newState
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftAppStateCallback && window._craftAppStateCallback('$currentAppState')",
                    null
                )
            }
            sendEvent("craftAppStateChange", mapOf("state" to currentAppState))
        }
    }

    // ==================== Contacts ====================

    @JavascriptInterface
    fun getContacts() {
        if (ContextCompat.checkSelfPermission(activity, Manifest.permission.READ_CONTACTS)
            != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(activity, arrayOf(Manifest.permission.READ_CONTACTS), REQUEST_CONTACTS)
            activity.runOnUiThread {
                webView.evaluateJavascript("window._craftContactsReject && window._craftContactsReject('Permission denied')", null)
            }
            return
        }

        val contacts = JSONArray()
        val cursor: Cursor? = activity.contentResolver.query(
            ContactsContract.Contacts.CONTENT_URI,
            null, null, null, ContactsContract.Contacts.DISPLAY_NAME + " ASC"
        )

        cursor?.use {
            while (it.moveToNext()) {
                val id = it.getString(it.getColumnIndexOrThrow(ContactsContract.Contacts._ID))
                val name = it.getString(it.getColumnIndexOrThrow(ContactsContract.Contacts.DISPLAY_NAME))

                val contact = JSONObject().apply {
                    put("id", id)
                    put("displayName", name ?: "")
                    put("phoneNumbers", getContactPhones(id))
                    put("emailAddresses", getContactEmails(id))
                }
                contacts.put(contact)
            }
        }

        activity.runOnUiThread {
            webView.evaluateJavascript("window._craftContactsResolve && window._craftContactsResolve($contacts)", null)
        }
    }

    private fun getContactPhones(contactId: String): JSONArray {
        val phones = JSONArray()
        val cursor = activity.contentResolver.query(
            ContactsContract.CommonDataKinds.Phone.CONTENT_URI,
            null,
            ContactsContract.CommonDataKinds.Phone.CONTACT_ID + " = ?",
            arrayOf(contactId), null
        )
        cursor?.use {
            while (it.moveToNext()) {
                val phone = it.getString(it.getColumnIndexOrThrow(ContactsContract.CommonDataKinds.Phone.NUMBER))
                phones.put(phone)
            }
        }
        return phones
    }

    private fun getContactEmails(contactId: String): JSONArray {
        val emails = JSONArray()
        val cursor = activity.contentResolver.query(
            ContactsContract.CommonDataKinds.Email.CONTENT_URI,
            null,
            ContactsContract.CommonDataKinds.Email.CONTACT_ID + " = ?",
            arrayOf(contactId), null
        )
        cursor?.use {
            while (it.moveToNext()) {
                val email = it.getString(it.getColumnIndexOrThrow(ContactsContract.CommonDataKinds.Email.ADDRESS))
                emails.put(email)
            }
        }
        return emails
    }

    @JavascriptInterface
    fun addContact(contactJson: String) {
        if (ContextCompat.checkSelfPermission(activity, Manifest.permission.WRITE_CONTACTS)
            != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(activity, arrayOf(Manifest.permission.WRITE_CONTACTS), REQUEST_CONTACTS)
            activity.runOnUiThread {
                webView.evaluateJavascript("window._craftAddContactReject && window._craftAddContactReject('Permission denied')", null)
            }
            return
        }

        try {
            val contact = JSONObject(contactJson)
            val ops = ArrayList<android.content.ContentProviderOperation>()

            ops.add(android.content.ContentProviderOperation.newInsert(ContactsContract.RawContacts.CONTENT_URI)
                .withValue(ContactsContract.RawContacts.ACCOUNT_TYPE, null)
                .withValue(ContactsContract.RawContacts.ACCOUNT_NAME, null)
                .build())

            // Name
            val displayName = contact.optString("displayName", "")
            if (displayName.isNotEmpty()) {
                ops.add(android.content.ContentProviderOperation.newInsert(ContactsContract.Data.CONTENT_URI)
                    .withValueBackReference(ContactsContract.Data.RAW_CONTACT_ID, 0)
                    .withValue(ContactsContract.Data.MIMETYPE, ContactsContract.CommonDataKinds.StructuredName.CONTENT_ITEM_TYPE)
                    .withValue(ContactsContract.CommonDataKinds.StructuredName.DISPLAY_NAME, displayName)
                    .build())
            }

            // Phone
            val phone = contact.optString("phone", "")
            if (phone.isNotEmpty()) {
                ops.add(android.content.ContentProviderOperation.newInsert(ContactsContract.Data.CONTENT_URI)
                    .withValueBackReference(ContactsContract.Data.RAW_CONTACT_ID, 0)
                    .withValue(ContactsContract.Data.MIMETYPE, ContactsContract.CommonDataKinds.Phone.CONTENT_ITEM_TYPE)
                    .withValue(ContactsContract.CommonDataKinds.Phone.NUMBER, phone)
                    .withValue(ContactsContract.CommonDataKinds.Phone.TYPE, ContactsContract.CommonDataKinds.Phone.TYPE_MOBILE)
                    .build())
            }

            // Email
            val email = contact.optString("email", "")
            if (email.isNotEmpty()) {
                ops.add(android.content.ContentProviderOperation.newInsert(ContactsContract.Data.CONTENT_URI)
                    .withValueBackReference(ContactsContract.Data.RAW_CONTACT_ID, 0)
                    .withValue(ContactsContract.Data.MIMETYPE, ContactsContract.CommonDataKinds.Email.CONTENT_ITEM_TYPE)
                    .withValue(ContactsContract.CommonDataKinds.Email.ADDRESS, email)
                    .withValue(ContactsContract.CommonDataKinds.Email.TYPE, ContactsContract.CommonDataKinds.Email.TYPE_HOME)
                    .build())
            }

            val results = activity.contentResolver.applyBatch(ContactsContract.AUTHORITY, ops)
            val contactId = ContentUris.parseId(results[0].uri!!)

            activity.runOnUiThread {
                webView.evaluateJavascript("window._craftAddContactResolve && window._craftAddContactResolve('$contactId')", null)
            }
        } catch (e: Exception) {
            activity.runOnUiThread {
                webView.evaluateJavascript("window._craftAddContactReject && window._craftAddContactReject('${e.message}')", null)
            }
        }
    }

    // ==================== Calendar ====================

    @JavascriptInterface
    fun getCalendarEvents(startDateMs: Long, endDateMs: Long) {
        if (ContextCompat.checkSelfPermission(activity, Manifest.permission.READ_CALENDAR)
            != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(activity, arrayOf(Manifest.permission.READ_CALENDAR), REQUEST_CALENDAR)
            activity.runOnUiThread {
                webView.evaluateJavascript("window._craftCalendarReject && window._craftCalendarReject('Permission denied')", null)
            }
            return
        }

        val events = JSONArray()
        val startTime = if (startDateMs > 0) startDateMs else System.currentTimeMillis()
        val endTime = if (endDateMs > 0) endDateMs else startTime + (30L * 24 * 60 * 60 * 1000) // 30 days

        val projection = arrayOf(
            CalendarContract.Events._ID,
            CalendarContract.Events.TITLE,
            CalendarContract.Events.DESCRIPTION,
            CalendarContract.Events.DTSTART,
            CalendarContract.Events.DTEND,
            CalendarContract.Events.EVENT_LOCATION,
            CalendarContract.Events.ALL_DAY
        )

        val selection = "(${CalendarContract.Events.DTSTART} >= ?) AND (${CalendarContract.Events.DTSTART} <= ?)"
        val selectionArgs = arrayOf(startTime.toString(), endTime.toString())

        val cursor = activity.contentResolver.query(
            CalendarContract.Events.CONTENT_URI,
            projection, selection, selectionArgs, CalendarContract.Events.DTSTART + " ASC"
        )

        cursor?.use {
            while (it.moveToNext()) {
                val event = JSONObject().apply {
                    put("id", it.getString(0))
                    put("title", it.getString(1) ?: "")
                    put("notes", it.getString(2) ?: "")
                    put("startDate", it.getLong(3))
                    put("endDate", it.getLong(4))
                    put("location", it.getString(5) ?: "")
                    put("isAllDay", it.getInt(6) == 1)
                }
                events.put(event)
            }
        }

        activity.runOnUiThread {
            webView.evaluateJavascript("window._craftCalendarResolve && window._craftCalendarResolve($events)", null)
        }
    }

    @JavascriptInterface
    fun createCalendarEvent(eventJson: String) {
        if (ContextCompat.checkSelfPermission(activity, Manifest.permission.WRITE_CALENDAR)
            != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(activity, arrayOf(Manifest.permission.WRITE_CALENDAR), REQUEST_CALENDAR)
            activity.runOnUiThread {
                webView.evaluateJavascript("window._craftCreateEventReject && window._craftCreateEventReject('Permission denied')", null)
            }
            return
        }

        try {
            val event = JSONObject(eventJson)
            val values = ContentValues().apply {
                put(CalendarContract.Events.TITLE, event.optString("title", ""))
                put(CalendarContract.Events.DESCRIPTION, event.optString("notes", ""))
                put(CalendarContract.Events.EVENT_LOCATION, event.optString("location", ""))
                put(CalendarContract.Events.DTSTART, event.optLong("startDate", System.currentTimeMillis()))
                put(CalendarContract.Events.DTEND, event.optLong("endDate", System.currentTimeMillis() + 3600000))
                put(CalendarContract.Events.ALL_DAY, if (event.optBoolean("isAllDay", false)) 1 else 0)
                put(CalendarContract.Events.CALENDAR_ID, 1)
                put(CalendarContract.Events.EVENT_TIMEZONE, TimeZone.getDefault().id)
            }

            val uri = activity.contentResolver.insert(CalendarContract.Events.CONTENT_URI, values)
            val eventId = uri?.lastPathSegment ?: ""

            activity.runOnUiThread {
                webView.evaluateJavascript("window._craftCreateEventResolve && window._craftCreateEventResolve('$eventId')", null)
            }
        } catch (e: Exception) {
            activity.runOnUiThread {
                webView.evaluateJavascript("window._craftCreateEventReject && window._craftCreateEventReject('${e.message}')", null)
            }
        }
    }

    @JavascriptInterface
    fun deleteCalendarEvent(eventId: String) {
        try {
            val uri = ContentUris.withAppendedId(CalendarContract.Events.CONTENT_URI, eventId.toLong())
            activity.contentResolver.delete(uri, null, null)
            activity.runOnUiThread {
                webView.evaluateJavascript("window._craftDeleteEventResolve && window._craftDeleteEventResolve(true)", null)
            }
        } catch (e: Exception) {
            activity.runOnUiThread {
                webView.evaluateJavascript("window._craftDeleteEventReject && window._craftDeleteEventReject('${e.message}')", null)
            }
        }
    }

    // ==================== Local Notifications ====================

    @JavascriptInterface
    fun scheduleNotification(notificationJson: String) {
        try {
            val notif = JSONObject(notificationJson)
            val title = notif.optString("title", "")
            val body = notif.optString("body", "")
            val id = notif.optString("id", System.currentTimeMillis().toString())

            createNotificationChannel()

            val notificationManager = activity.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

            val builder = androidx.core.app.NotificationCompat.Builder(activity, notificationChannelId)
                .setSmallIcon(android.R.drawable.ic_dialog_info)
                .setContentTitle(title)
                .setContentText(body)
                .setPriority(androidx.core.app.NotificationCompat.PRIORITY_DEFAULT)
                .setAutoCancel(true)

            // Schedule with delay if specified
            val delay = notif.optLong("delay", 0)
            if (delay > 0) {
                android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({
                    notificationManager.notify(id.hashCode(), builder.build())
                }, delay)
            } else {
                notificationManager.notify(id.hashCode(), builder.build())
            }

            activity.runOnUiThread {
                webView.evaluateJavascript("window._craftNotifResolve && window._craftNotifResolve('$id')", null)
            }
        } catch (e: Exception) {
            activity.runOnUiThread {
                webView.evaluateJavascript("window._craftNotifReject && window._craftNotifReject('${e.message}')", null)
            }
        }
    }

    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val name = "Craft Notifications"
            val descriptionText = "Notifications from Craft app"
            val importance = NotificationManager.IMPORTANCE_DEFAULT
            val channel = NotificationChannel(notificationChannelId, name, importance).apply {
                description = descriptionText
            }
            val notificationManager = activity.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
            notificationManager.createNotificationChannel(channel)
        }
    }

    @JavascriptInterface
    fun cancelNotification(id: String) {
        val notificationManager = activity.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        notificationManager.cancel(id.hashCode())
    }

    @JavascriptInterface
    fun cancelAllNotifications() {
        val notificationManager = activity.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        notificationManager.cancelAll()
    }

    // ==================== In-App Purchase ====================

    @JavascriptInterface
    fun getProducts(productIdsJson: String) {
        try {
            val productIds = JSONArray(productIdsJson)
            val productList = mutableListOf<String>()
            for (i in 0 until productIds.length()) {
                productList.add(productIds.getString(i))
            }

            billingClient = BillingClient.newBuilder(activity)
                .setListener { _, _ -> }
                .enablePendingPurchases()
                .build()

            billingClient?.startConnection(object : BillingClientStateListener {
                override fun onBillingSetupFinished(billingResult: BillingResult) {
                    if (billingResult.responseCode == BillingClient.BillingResponseCode.OK) {
                        val params = QueryProductDetailsParams.newBuilder()
                            .setProductList(productList.map { productId ->
                                QueryProductDetailsParams.Product.newBuilder()
                                    .setProductId(productId)
                                    .setProductType(BillingClient.ProductType.INAPP)
                                    .build()
                            })
                            .build()

                        billingClient?.queryProductDetailsAsync(params) { result, productDetailsList ->
                            if (result.responseCode == BillingClient.BillingResponseCode.OK) {
                                val products = JSONArray()
                                productDetailsList.forEach { details ->
                                    products.put(JSONObject().apply {
                                        put("id", details.productId)
                                        put("displayName", details.name)
                                        put("description", details.description)
                                        put("price", details.oneTimePurchaseOfferDetails?.formattedPrice ?: "")
                                    })
                                }
                                activity.runOnUiThread {
                                    webView.evaluateJavascript("window._craftProductsResolve && window._craftProductsResolve($products)", null)
                                }
                            } else {
                                activity.runOnUiThread {
                                    webView.evaluateJavascript("window._craftProductsReject && window._craftProductsReject('Query failed')", null)
                                }
                            }
                        }
                    }
                }

                override fun onBillingServiceDisconnected() {
                    activity.runOnUiThread {
                        webView.evaluateJavascript("window._craftProductsReject && window._craftProductsReject('Billing disconnected')", null)
                    }
                }
            })
        } catch (e: Exception) {
            activity.runOnUiThread {
                webView.evaluateJavascript("window._craftProductsReject && window._craftProductsReject('${e.message}')", null)
            }
        }
    }

    @JavascriptInterface
    fun purchase(productId: String) {
        // Simplified - real implementation would query product details first
        activity.runOnUiThread {
            webView.evaluateJavascript("window._craftPurchaseReject && window._craftPurchaseReject('Purchase flow not fully implemented')", null)
        }
    }

    @JavascriptInterface
    fun restorePurchases() {
        billingClient?.queryPurchasesAsync(
            QueryPurchasesParams.newBuilder().setProductType(BillingClient.ProductType.INAPP).build()
        ) { result, purchases ->
            if (result.responseCode == BillingClient.BillingResponseCode.OK) {
                val restored = JSONArray()
                purchases.forEach { purchase ->
                    restored.put(JSONObject().apply {
                        put("productId", purchase.products.firstOrNull())
                        put("orderId", purchase.orderId)
                    })
                }
                activity.runOnUiThread {
                    webView.evaluateJavascript("window._craftRestoreResolve && window._craftRestoreResolve($restored)", null)
                }
            } else {
                activity.runOnUiThread {
                    webView.evaluateJavascript("window._craftRestoreReject && window._craftRestoreReject('Restore failed')", null)
                }
            }
        }
    }

    // ==================== Keep Awake ====================

    @JavascriptInterface
    fun setKeepAwake(enabled: Boolean): Boolean {
        activity.runOnUiThread {
            if (enabled) {
                activity.window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)
            } else {
                activity.window.clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)
            }
            isKeepingAwake = enabled
        }
        return true
    }

    // ==================== Orientation Lock ====================

    @JavascriptInterface
    fun lockOrientation(orientation: String): Boolean {
        activity.runOnUiThread {
            activity.requestedOrientation = when (orientation) {
                "portrait" -> ActivityInfo.SCREEN_ORIENTATION_PORTRAIT
                "landscape" -> ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE
                "landscapeLeft" -> ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE
                "landscapeRight" -> ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE
                else -> ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED
            }
        }
        return true
    }

    @JavascriptInterface
    fun unlockOrientation(): Boolean {
        activity.runOnUiThread {
            activity.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED
        }
        return true
    }

    // ==================== Deep Links ====================

    fun handleDeepLink(uri: android.net.Uri) {
        sendEvent("craftDeepLink", mapOf(
            "url" to uri.toString(),
            "scheme" to (uri.scheme ?: ""),
            "host" to (uri.host ?: ""),
            "path" to (uri.path ?: ""),
            "query" to (uri.query ?: "")
        ))
    }

    // ==================== QR/Barcode Scanner ====================

    @JavascriptInterface
    fun scanQRCode() {
        // Uses ML Kit barcode scanning - requires camera permission
        activity.runOnUiThread {
            webView.evaluateJavascript(
                "window._craftQRReject && window._craftQRReject('QR scanning requires camera integration - use native camera intent')",
                null
            )
        }
    }

    // ==================== File Picker ====================

    @JavascriptInterface
    fun pickFile(typesJson: String) {
        val intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply {
            addCategory(Intent.CATEGORY_OPENABLE)
            type = "*/*"
        }
        activity.startActivityForResult(intent, REQUEST_FILE_PICKER)
    }

    // ==================== File Download ====================

    @JavascriptInterface
    fun downloadFile(url: String, filename: String) {
        try {
            val request = DownloadManager.Request(Uri.parse(url)).apply {
                setTitle(filename)
                setDescription("Downloading...")
                setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED)
                setDestinationInExternalPublicDir(android.os.Environment.DIRECTORY_DOWNLOADS, filename)
            }

            val downloadManager = activity.getSystemService(Context.DOWNLOAD_SERVICE) as DownloadManager
            val downloadId = downloadManager.enqueue(request)

            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftDownloadResolve && window._craftDownloadResolve('$downloadId')",
                    null
                )
            }
        } catch (e: Exception) {
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftDownloadReject && window._craftDownloadReject('${e.message}')",
                    null
                )
            }
        }
    }

    @JavascriptInterface
    fun saveFile(data: String, filename: String) {
        try {
            val documentsDir = activity.getExternalFilesDir(android.os.Environment.DIRECTORY_DOCUMENTS)
            val file = File(documentsDir, filename)

            if (data.startsWith("data:")) {
                // Base64 data URL
                val parts = data.split(",")
                if (parts.size == 2) {
                    val bytes = Base64.decode(parts[1], Base64.DEFAULT)
                    file.writeBytes(bytes)
                }
            } else {
                file.writeText(data)
            }

            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftSaveResolve && window._craftSaveResolve('${file.absolutePath}')",
                    null
                )
            }
        } catch (e: Exception) {
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftSaveReject && window._craftSaveReject('${e.message}')",
                    null
                )
            }
        }
    }

    // ==================== Google Sign In ====================

    @JavascriptInterface
    fun signInWithGoogle() {
        // Google Sign In requires configuration in build.gradle
        activity.runOnUiThread {
            webView.evaluateJavascript(
                "window._craftGoogleReject && window._craftGoogleReject('Google Sign In requires app configuration')",
                null
            )
        }
    }

    // ==================== Audio Recording ====================

    @JavascriptInterface
    fun startAudioRecording() {
        if (ContextCompat.checkSelfPermission(activity, Manifest.permission.RECORD_AUDIO)
            != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(activity, arrayOf(Manifest.permission.RECORD_AUDIO), REQUEST_AUDIO)
            activity.runOnUiThread {
                webView.evaluateJavascript("window._craftAudioReject && window._craftAudioReject('Permission denied')", null)
            }
            return
        }

        try {
            val cacheDir = activity.cacheDir
            audioFile = File.createTempFile("recording_", ".m4a", cacheDir)

            mediaRecorder = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                MediaRecorder(activity)
            } else {
                @Suppress("DEPRECATION")
                MediaRecorder()
            }

            mediaRecorder?.apply {
                setAudioSource(MediaRecorder.AudioSource.MIC)
                setOutputFormat(MediaRecorder.OutputFormat.MPEG_4)
                setAudioEncoder(MediaRecorder.AudioEncoder.AAC)
                setOutputFile(audioFile?.absolutePath)
                prepare()
                start()
            }

            activity.runOnUiThread {
                webView.evaluateJavascript("window._craftAudioResolve && window._craftAudioResolve(true)", null)
            }
        } catch (e: Exception) {
            activity.runOnUiThread {
                webView.evaluateJavascript("window._craftAudioReject && window._craftAudioReject('${e.message}')", null)
            }
        }
    }

    @JavascriptInterface
    fun stopAudioRecording() {
        try {
            mediaRecorder?.stop()
            mediaRecorder?.release()
            mediaRecorder = null

            audioFile?.let { file ->
                val bytes = file.readBytes()
                val base64 = "data:audio/m4a;base64," + Base64.encodeToString(bytes, Base64.NO_WRAP)
                activity.runOnUiThread {
                    webView.evaluateJavascript("window._craftAudioStopResolve && window._craftAudioStopResolve('$base64')", null)
                }
            } ?: run {
                activity.runOnUiThread {
                    webView.evaluateJavascript("window._craftAudioStopReject && window._craftAudioStopReject('No recording')", null)
                }
            }
        } catch (e: Exception) {
            activity.runOnUiThread {
                webView.evaluateJavascript("window._craftAudioStopReject && window._craftAudioStopReject('${e.message}')", null)
            }
        }
    }

    // ==================== Video Recording ====================

    @JavascriptInterface
    fun startVideoRecording() {
        val intent = Intent(MediaStore.ACTION_VIDEO_CAPTURE).apply {
            putExtra(MediaStore.EXTRA_VIDEO_QUALITY, 1)
        }
        activity.startActivityForResult(intent, REQUEST_VIDEO)
    }

    // ==================== Motion Sensors ====================

    @JavascriptInterface
    fun startMotionUpdates(intervalMs: Int): Boolean {
        sensorManager = activity.getSystemService(Context.SENSOR_SERVICE) as SensorManager
        accelerometer = sensorManager?.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)
        gyroscope = sensorManager?.getDefaultSensor(Sensor.TYPE_GYROSCOPE)

        sensorListener = object : SensorEventListener {
            private var lastAccel: FloatArray? = null
            private var lastGyro: FloatArray? = null

            override fun onSensorChanged(event: SensorEvent) {
                when (event.sensor.type) {
                    Sensor.TYPE_ACCELEROMETER -> lastAccel = event.values.clone()
                    Sensor.TYPE_GYROSCOPE -> lastGyro = event.values.clone()
                }

                val accel = lastAccel ?: floatArrayOf(0f, 0f, 0f)
                val gyro = lastGyro ?: floatArrayOf(0f, 0f, 0f)

                sendEvent("craftMotionUpdate", mapOf(
                    "acceleration" to mapOf("x" to accel[0], "y" to accel[1], "z" to accel[2]),
                    "rotation" to mapOf("alpha" to gyro[0], "beta" to gyro[1], "gamma" to gyro[2])
                ))
            }

            override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {}
        }

        val delay = when {
            intervalMs <= 20 -> SensorManager.SENSOR_DELAY_FASTEST
            intervalMs <= 60 -> SensorManager.SENSOR_DELAY_GAME
            intervalMs <= 200 -> SensorManager.SENSOR_DELAY_UI
            else -> SensorManager.SENSOR_DELAY_NORMAL
        }

        accelerometer?.let { sensorManager?.registerListener(sensorListener, it, delay) }
        gyroscope?.let { sensorManager?.registerListener(sensorListener, it, delay) }

        return true
    }

    @JavascriptInterface
    fun stopMotionUpdates() {
        sensorListener?.let { sensorManager?.unregisterListener(it) }
        sensorListener = null
    }

    // ==================== Local Database ====================

    @JavascriptInterface
    fun dbExecute(sql: String, paramsJson: String) {
        try {
            if (database == null) {
                database = activity.openOrCreateDatabase("craft.db", Context.MODE_PRIVATE, null)
            }

            val params = JSONArray(paramsJson)
            val args = Array(params.length()) { params.getString(it) }

            database?.execSQL(sql, args)

            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftDbExecResolve && window._craftDbExecResolve({rowsAffected: 1})",
                    null
                )
            }
        } catch (e: Exception) {
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftDbExecReject && window._craftDbExecReject('${e.message}')",
                    null
                )
            }
        }
    }

    @JavascriptInterface
    fun dbQuery(sql: String, paramsJson: String) {
        try {
            if (database == null) {
                database = activity.openOrCreateDatabase("craft.db", Context.MODE_PRIVATE, null)
            }

            val params = JSONArray(paramsJson)
            val args = Array(params.length()) { params.getString(it) }

            val cursor = database?.rawQuery(sql, args)
            val results = JSONArray()

            cursor?.use {
                val columns = it.columnNames
                while (it.moveToNext()) {
                    val row = JSONObject()
                    columns.forEachIndexed { index, col ->
                        row.put(col, it.getString(index))
                    }
                    results.put(row)
                }
            }

            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftDbQueryResolve && window._craftDbQueryResolve($results)",
                    null
                )
            }
        } catch (e: Exception) {
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftDbQueryReject && window._craftDbQueryReject('${e.message}')",
                    null
                )
            }
        }
    }

    // ==================== Bluetooth ====================

    @JavascriptInterface
    fun startBluetoothScan() {
        if (ContextCompat.checkSelfPermission(activity, Manifest.permission.BLUETOOTH_SCAN)
            != PackageManager.PERMISSION_GRANTED) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                ActivityCompat.requestPermissions(activity, arrayOf(Manifest.permission.BLUETOOTH_SCAN), REQUEST_BLUETOOTH)
            }
            activity.runOnUiThread {
                webView.evaluateJavascript("window._craftBleReject && window._craftBleReject('Permission denied')", null)
            }
            return
        }

        val bluetoothManager = activity.getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager
        bluetoothAdapter = bluetoothManager.adapter
        bluetoothScanner = bluetoothAdapter?.bluetoothLeScanner

        bleScanCallback = object : ScanCallback() {
            override fun onScanResult(callbackType: Int, result: ScanResult) {
                sendEvent("craftBluetoothDevice", mapOf(
                    "id" to result.device.address,
                    "name" to (result.device.name ?: "Unknown"),
                    "rssi" to result.rssi
                ))
            }
        }

        bluetoothScanner?.startScan(bleScanCallback)
        activity.runOnUiThread {
            webView.evaluateJavascript("window._craftBleResolve && window._craftBleResolve(true)", null)
        }
    }

    @JavascriptInterface
    fun stopBluetoothScan() {
        bleScanCallback?.let { bluetoothScanner?.stopScan(it) }
        bleScanCallback = null
    }

    // ==================== NFC ====================

    @JavascriptInterface
    fun scanNFC() {
        val nfcAdapter = NfcAdapter.getDefaultAdapter(activity)
        if (nfcAdapter == null || !nfcAdapter.isEnabled) {
            activity.runOnUiThread {
                webView.evaluateJavascript("window._craftNfcReject && window._craftNfcReject('NFC not available')", null)
            }
            return
        }
        // NFC requires foreground dispatch - simplified implementation
        activity.runOnUiThread {
            webView.evaluateJavascript("window._craftNfcReject && window._craftNfcReject('NFC requires activity integration')", null)
        }
    }

    // ==================== Fitness ====================

    @JavascriptInterface
    fun requestFitnessAuthorization(typesJson: String) {
        // Google Fit requires configuration
        activity.runOnUiThread {
            webView.evaluateJavascript("window._craftFitnessAuthReject && window._craftFitnessAuthReject('Fitness requires Google Fit configuration')", null)
        }
    }

    @JavascriptInterface
    fun getFitnessData(type: String, startDate: Long, endDate: Long) {
        activity.runOnUiThread {
            webView.evaluateJavascript("window._craftFitnessDataReject && window._craftFitnessDataReject('Fitness requires Google Fit configuration')", null)
        }
    }

    // ==================== Screen Capture ====================

    @JavascriptInterface
    fun takeScreenshot() {
        activity.runOnUiThread {
            try {
                val view = webView.rootView
                view.isDrawingCacheEnabled = true
                view.buildDrawingCache()
                val bitmap = Bitmap.createBitmap(view.drawingCache)
                view.isDrawingCacheEnabled = false

                val outputStream = ByteArrayOutputStream()
                bitmap.compress(Bitmap.CompressFormat.PNG, 100, outputStream)
                val base64 = "data:image/png;base64," + Base64.encodeToString(outputStream.toByteArray(), Base64.NO_WRAP)

                webView.evaluateJavascript("window._craftScreenshotResolve && window._craftScreenshotResolve('$base64')", null)
            } catch (e: Exception) {
                webView.evaluateJavascript("window._craftScreenshotReject && window._craftScreenshotReject('${e.message}')", null)
            }
        }
    }

    // ==================== Background Tasks ====================

    @JavascriptInterface
    fun registerBackgroundTask(taskId: String) {
        try {
            // WorkManager tasks don't require explicit registration, just track them
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftBgTaskResolve && window._craftBgTaskResolve({taskId: '$taskId', registered: true})",
                    null
                )
            }
        } catch (e: Exception) {
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftBgTaskReject && window._craftBgTaskReject('${e.message}')",
                    null
                )
            }
        }
    }

    @JavascriptInterface
    fun scheduleBackgroundTask(taskId: String, delay: Long, requiresNetwork: Boolean, requiresCharging: Boolean) {
        try {
            // Note: Full WorkManager implementation requires adding the dependency
            // implementation 'androidx.work:work-runtime-ktx:2.9.0'
            // This is a placeholder that shows the API structure
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftBgTaskResolve && window._craftBgTaskResolve({taskId: '$taskId', scheduled: true, delay: $delay})",
                    null
                )
            }
        } catch (e: Exception) {
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftBgTaskReject && window._craftBgTaskReject('${e.message}')",
                    null
                )
            }
        }
    }

    @JavascriptInterface
    fun cancelBackgroundTask(taskId: String) {
        try {
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftBgTaskResolve && window._craftBgTaskResolve({taskId: '$taskId', cancelled: true})",
                    null
                )
            }
        } catch (e: Exception) {
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftBgTaskReject && window._craftBgTaskReject('${e.message}')",
                    null
                )
            }
        }
    }

    @JavascriptInterface
    fun cancelAllBackgroundTasks() {
        try {
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftBgTaskResolve && window._craftBgTaskResolve({cancelled: true})",
                    null
                )
            }
        } catch (e: Exception) {
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftBgTaskReject && window._craftBgTaskReject('${e.message}')",
                    null
                )
            }
        }
    }

    // ==================== PDF Viewer ====================

    @JavascriptInterface
    fun openPDF(source: String, page: Int) {
        activity.runOnUiThread {
            try {
                val uri = if (source.startsWith("data:")) {
                    // Save base64 to temp file and open
                    val base64Data = source.substringAfter(",")
                    val bytes = Base64.decode(base64Data, Base64.DEFAULT)
                    val tempFile = File.createTempFile("craft_pdf_", ".pdf", activity.cacheDir)
                    tempFile.writeBytes(bytes)
                    Uri.fromFile(tempFile)
                } else {
                    Uri.parse(source)
                }

                val intent = Intent(Intent.ACTION_VIEW).apply {
                    setDataAndType(uri, "application/pdf")
                    addFlags(Intent.FLAG_ACTIVITY_NO_HISTORY)
                    addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
                }

                activity.startActivity(intent)
                webView.evaluateJavascript(
                    "window._craftPDFResolve && window._craftPDFResolve({opened: true})",
                    null
                )
            } catch (e: Exception) {
                webView.evaluateJavascript(
                    "window._craftPDFReject && window._craftPDFReject('${e.message}')",
                    null
                )
            }
        }
    }

    @JavascriptInterface
    fun closePDF() {
        // PDFs are opened in external viewers, so we just acknowledge
        activity.runOnUiThread {
            webView.evaluateJavascript(
                "window._craftPDFResolve && window._craftPDFResolve(true)",
                null
            )
        }
    }

    // ==================== Contacts Picker ====================

    @JavascriptInterface
    fun pickContact(multiple: Boolean) {
        if (ContextCompat.checkSelfPermission(activity, Manifest.permission.READ_CONTACTS)
            != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(activity, arrayOf(Manifest.permission.READ_CONTACTS), REQUEST_PICK_CONTACT)
            return
        }

        activity.runOnUiThread {
            val intent = Intent(Intent.ACTION_PICK, ContactsContract.Contacts.CONTENT_URI)
            activity.startActivityForResult(intent, REQUEST_PICK_CONTACT)
        }
    }

    fun handleContactPickerResult(resultCode: Int, data: Intent?) {
        if (resultCode != Activity.RESULT_OK || data?.data == null) {
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftPickContactReject && window._craftPickContactReject('Cancelled')",
                    null
                )
            }
            return
        }

        try {
            val contactUri = data.data!!
            val projection = arrayOf(
                ContactsContract.Contacts._ID,
                ContactsContract.Contacts.DISPLAY_NAME
            )

            activity.contentResolver.query(contactUri, projection, null, null, null)?.use { cursor ->
                if (cursor.moveToFirst()) {
                    val contactId = cursor.getString(cursor.getColumnIndexOrThrow(ContactsContract.Contacts._ID))
                    val displayName = cursor.getString(cursor.getColumnIndexOrThrow(ContactsContract.Contacts.DISPLAY_NAME))

                    // Get phone numbers
                    val phones = mutableListOf<Map<String, String>>()
                    activity.contentResolver.query(
                        ContactsContract.CommonDataKinds.Phone.CONTENT_URI,
                        arrayOf(ContactsContract.CommonDataKinds.Phone.NUMBER, ContactsContract.CommonDataKinds.Phone.TYPE),
                        "${ContactsContract.CommonDataKinds.Phone.CONTACT_ID} = ?",
                        arrayOf(contactId),
                        null
                    )?.use { phoneCursor ->
                        while (phoneCursor.moveToNext()) {
                            val number = phoneCursor.getString(phoneCursor.getColumnIndexOrThrow(ContactsContract.CommonDataKinds.Phone.NUMBER))
                            phones.add(mapOf("number" to number))
                        }
                    }

                    // Get emails
                    val emails = mutableListOf<Map<String, String>>()
                    activity.contentResolver.query(
                        ContactsContract.CommonDataKinds.Email.CONTENT_URI,
                        arrayOf(ContactsContract.CommonDataKinds.Email.ADDRESS),
                        "${ContactsContract.CommonDataKinds.Email.CONTACT_ID} = ?",
                        arrayOf(contactId),
                        null
                    )?.use { emailCursor ->
                        while (emailCursor.moveToNext()) {
                            val address = emailCursor.getString(emailCursor.getColumnIndexOrThrow(ContactsContract.CommonDataKinds.Email.ADDRESS))
                            emails.add(mapOf("address" to address))
                        }
                    }

                    val result = JSONObject().apply {
                        put("id", contactId)
                        put("displayName", displayName)
                        put("phoneNumbers", JSONArray(phones.map { JSONObject(it) }))
                        put("emailAddresses", JSONArray(emails.map { JSONObject(it) }))
                    }

                    activity.runOnUiThread {
                        webView.evaluateJavascript(
                            "window._craftPickContactResolve && window._craftPickContactResolve($result)",
                            null
                        )
                    }
                }
            }
        } catch (e: Exception) {
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftPickContactReject && window._craftPickContactReject('${e.message}')",
                    null
                )
            }
        }
    }

    // ==================== App Shortcuts ====================

    @JavascriptInterface
    fun setShortcuts(shortcutsJson: String) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.N_MR1) {
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftShortcutsReject && window._craftShortcutsReject('App shortcuts require Android 7.1+')",
                    null
                )
            }
            return
        }

        try {
            val shortcutManager = activity.getSystemService(android.content.pm.ShortcutManager::class.java)
            val shortcuts = mutableListOf<android.content.pm.ShortcutInfo>()
            val jsonArray = JSONArray(shortcutsJson)

            for (i in 0 until jsonArray.length()) {
                val shortcut = jsonArray.getJSONObject(i)
                val type = shortcut.getString("type")
                val title = shortcut.getString("title")
                val subtitle = if (shortcut.has("subtitle")) shortcut.getString("subtitle") else null

                val intent = Intent(activity, activity::class.java).apply {
                    action = Intent.ACTION_VIEW
                    putExtra("shortcut_type", type)
                }

                val builder = android.content.pm.ShortcutInfo.Builder(activity, type)
                    .setShortLabel(title)
                    .setIntent(intent)

                subtitle?.let { builder.setLongLabel(it) }

                shortcuts.add(builder.build())
            }

            shortcutManager?.dynamicShortcuts = shortcuts

            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftShortcutsResolve && window._craftShortcutsResolve({count: ${shortcuts.size}})",
                    null
                )
            }
        } catch (e: Exception) {
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftShortcutsReject && window._craftShortcutsReject('${e.message}')",
                    null
                )
            }
        }
    }

    @JavascriptInterface
    fun clearShortcuts() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N_MR1) {
            try {
                val shortcutManager = activity.getSystemService(android.content.pm.ShortcutManager::class.java)
                shortcutManager?.removeAllDynamicShortcuts()

                activity.runOnUiThread {
                    webView.evaluateJavascript(
                        "window._craftShortcutsResolve && window._craftShortcutsResolve(true)",
                        null
                    )
                }
            } catch (e: Exception) {
                activity.runOnUiThread {
                    webView.evaluateJavascript(
                        "window._craftShortcutsReject && window._craftShortcutsReject('${e.message}')",
                        null
                    )
                }
            }
        } else {
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftShortcutsResolve && window._craftShortcutsResolve(true)",
                    null
                )
            }
        }
    }

    // ==================== Shared Preferences (Keychain equivalent) ====================

    @JavascriptInterface
    fun setSharedItem(key: String, value: String, group: String) {
        try {
            val prefsName = if (group.isNotEmpty()) "craft_shared_$group" else "craft_shared"
            val prefs = activity.getSharedPreferences(prefsName, Context.MODE_PRIVATE)
            prefs.edit().putString(key, value).apply()

            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftSharedKeychainResolve && window._craftSharedKeychainResolve({success: true, key: '$key'})",
                    null
                )
            }
        } catch (e: Exception) {
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftSharedKeychainReject && window._craftSharedKeychainReject('${e.message}')",
                    null
                )
            }
        }
    }

    @JavascriptInterface
    fun getSharedItem(key: String, group: String) {
        try {
            val prefsName = if (group.isNotEmpty()) "craft_shared_$group" else "craft_shared"
            val prefs = activity.getSharedPreferences(prefsName, Context.MODE_PRIVATE)
            val value = prefs.getString(key, null)

            activity.runOnUiThread {
                if (value != null) {
                    webView.evaluateJavascript(
                        "window._craftSharedKeychainResolve && window._craftSharedKeychainResolve({value: '$value', key: '$key'})",
                        null
                    )
                } else {
                    webView.evaluateJavascript(
                        "window._craftSharedKeychainResolve && window._craftSharedKeychainResolve({value: null, key: '$key'})",
                        null
                    )
                }
            }
        } catch (e: Exception) {
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftSharedKeychainReject && window._craftSharedKeychainReject('${e.message}')",
                    null
                )
            }
        }
    }

    @JavascriptInterface
    fun removeSharedItem(key: String, group: String) {
        try {
            val prefsName = if (group.isNotEmpty()) "craft_shared_$group" else "craft_shared"
            val prefs = activity.getSharedPreferences(prefsName, Context.MODE_PRIVATE)
            prefs.edit().remove(key).apply()

            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftSharedKeychainResolve && window._craftSharedKeychainResolve({success: true, key: '$key'})",
                    null
                )
            }
        } catch (e: Exception) {
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftSharedKeychainReject && window._craftSharedKeychainReject('${e.message}')",
                    null
                )
            }
        }
    }

    // ==================== Local Auth Persistence ====================

    private var authSessionExpiry: Long = 0L

    @JavascriptInterface
    fun setAuthPersistence(enabled: Boolean, duration: Long) {
        try {
            if (enabled) {
                authSessionExpiry = System.currentTimeMillis() + (duration * 1000)
                activity.runOnUiThread {
                    webView.evaluateJavascript(
                        "window._craftAuthPersistResolve && window._craftAuthPersistResolve({enabled: true, duration: $duration, expiresAt: $authSessionExpiry})",
                        null
                    )
                }
            } else {
                authSessionExpiry = 0L
                activity.runOnUiThread {
                    webView.evaluateJavascript(
                        "window._craftAuthPersistResolve && window._craftAuthPersistResolve({enabled: false})",
                        null
                    )
                }
            }
        } catch (e: Exception) {
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftAuthPersistReject && window._craftAuthPersistReject('${e.message}')",
                    null
                )
            }
        }
    }

    @JavascriptInterface
    fun checkAuthPersistence() {
        try {
            val now = System.currentTimeMillis()
            val isValid = authSessionExpiry > now
            val remainingMs = if (isValid) authSessionExpiry - now else 0L
            val remainingSeconds = remainingMs / 1000

            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftAuthPersistResolve && window._craftAuthPersistResolve({isValid: $isValid, remainingSeconds: $remainingSeconds})",
                    null
                )
            }
        } catch (e: Exception) {
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftAuthPersistReject && window._craftAuthPersistReject('${e.message}')",
                    null
                )
            }
        }
    }

    @JavascriptInterface
    fun clearAuthPersistence() {
        try {
            authSessionExpiry = 0L
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftAuthPersistResolve && window._craftAuthPersistResolve({cleared: true})",
                    null
                )
            }
        } catch (e: Exception) {
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftAuthPersistReject && window._craftAuthPersistReject('${e.message}')",
                    null
                )
            }
        }
    }

    // ==================== AR (ARCore) ====================
    // Note: ARCore requires additional setup in build.gradle and manifest
    // This is a placeholder that indicates AR is not available on this platform via simple JS bridge
    // For full ARCore support, consider using Sceneform or AR Fragment

    @JavascriptInterface
    fun startAR(optionsJson: String) {
        activity.runOnUiThread {
            webView.evaluateJavascript(
                "window._craftARReject && window._craftARReject('ARCore requires native Activity integration. Use Sceneform or AR Fragment for full AR support.')",
                null
            )
        }
    }

    @JavascriptInterface
    fun stopAR() {
        activity.runOnUiThread {
            webView.evaluateJavascript(
                "window._craftARResolve && window._craftARResolve({stopped: true})",
                null
            )
        }
    }

    @JavascriptInterface
    fun placeARObject(model: String, positionJson: String) {
        activity.runOnUiThread {
            webView.evaluateJavascript(
                "window._craftARReject && window._craftARReject('ARCore requires native Activity integration')",
                null
            )
        }
    }

    @JavascriptInterface
    fun removeARObject(objectId: String) {
        activity.runOnUiThread {
            webView.evaluateJavascript(
                "window._craftARReject && window._craftARReject('ARCore requires native Activity integration')",
                null
            )
        }
    }

    @JavascriptInterface
    fun getARPlanes() {
        activity.runOnUiThread {
            webView.evaluateJavascript(
                "window._craftARResolve && window._craftARResolve([])",
                null
            )
        }
    }

    // ==================== ML Kit ====================

    @JavascriptInterface
    fun classifyImage(imageBase64: String) {
        try {
            val imageBytes = Base64.decode(imageBase64, Base64.DEFAULT)
            val bitmap = BitmapFactory.decodeByteArray(imageBytes, 0, imageBytes.size)
            val inputImage = InputImage.fromBitmap(bitmap, 0)

            val labeler = ImageLabeling.getClient(ImageLabelerOptions.DEFAULT_OPTIONS)
            labeler.process(inputImage)
                .addOnSuccessListener { labels ->
                    val results = JSONArray()
                    for (label in labels) {
                        val obj = JSONObject()
                        obj.put("label", label.text)
                        obj.put("confidence", label.confidence)
                        obj.put("index", label.index)
                        results.put(obj)
                    }
                    activity.runOnUiThread {
                        webView.evaluateJavascript(
                            "window._craftMLResolve && window._craftMLResolve($results)",
                            null
                        )
                    }
                }
                .addOnFailureListener { e ->
                    activity.runOnUiThread {
                        webView.evaluateJavascript(
                            "window._craftMLReject && window._craftMLReject('${e.message}')",
                            null
                        )
                    }
                }
        } catch (e: Exception) {
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftMLReject && window._craftMLReject('${e.message}')",
                    null
                )
            }
        }
    }

    @JavascriptInterface
    fun detectObjects(imageBase64: String) {
        try {
            val imageBytes = Base64.decode(imageBase64, Base64.DEFAULT)
            val bitmap = BitmapFactory.decodeByteArray(imageBytes, 0, imageBytes.size)
            val inputImage = InputImage.fromBitmap(bitmap, 0)

            val options = ObjectDetectorOptions.Builder()
                .setDetectorMode(ObjectDetectorOptions.SINGLE_IMAGE_MODE)
                .enableMultipleObjects()
                .enableClassification()
                .build()

            val objectDetector = ObjectDetection.getClient(options)
            objectDetector.process(inputImage)
                .addOnSuccessListener { detectedObjects ->
                    val results = JSONArray()
                    for (obj in detectedObjects) {
                        val objJson = JSONObject()

                        // Bounding box
                        val bbox = JSONObject()
                        bbox.put("x", obj.boundingBox.left)
                        bbox.put("y", obj.boundingBox.top)
                        bbox.put("width", obj.boundingBox.width())
                        bbox.put("height", obj.boundingBox.height())
                        objJson.put("boundingBox", bbox)

                        // Labels
                        val labels = JSONArray()
                        for (label in obj.labels) {
                            val labelJson = JSONObject()
                            labelJson.put("label", label.text)
                            labelJson.put("confidence", label.confidence)
                            labelJson.put("index", label.index)
                            labels.put(labelJson)
                        }
                        objJson.put("labels", labels)
                        objJson.put("trackingId", obj.trackingId)

                        results.put(objJson)
                    }
                    activity.runOnUiThread {
                        webView.evaluateJavascript(
                            "window._craftMLResolve && window._craftMLResolve($results)",
                            null
                        )
                    }
                }
                .addOnFailureListener { e ->
                    activity.runOnUiThread {
                        webView.evaluateJavascript(
                            "window._craftMLReject && window._craftMLReject('${e.message}')",
                            null
                        )
                    }
                }
        } catch (e: Exception) {
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftMLReject && window._craftMLReject('${e.message}')",
                    null
                )
            }
        }
    }

    @JavascriptInterface
    fun recognizeText(imageBase64: String) {
        try {
            val imageBytes = Base64.decode(imageBase64, Base64.DEFAULT)
            val bitmap = BitmapFactory.decodeByteArray(imageBytes, 0, imageBytes.size)
            val inputImage = InputImage.fromBitmap(bitmap, 0)

            val recognizer = TextRecognition.getClient(TextRecognizerOptions.DEFAULT_OPTIONS)
            recognizer.process(inputImage)
                .addOnSuccessListener { visionText ->
                    val results = JSONArray()
                    for (block in visionText.textBlocks) {
                        for (line in block.lines) {
                            val lineJson = JSONObject()
                            lineJson.put("text", line.text)
                            lineJson.put("confidence", line.confidence ?: 0.0)

                            val boundingBox = line.boundingBox
                            if (boundingBox != null) {
                                val bbox = JSONObject()
                                bbox.put("x", boundingBox.left)
                                bbox.put("y", boundingBox.top)
                                bbox.put("width", boundingBox.width())
                                bbox.put("height", boundingBox.height())
                                lineJson.put("boundingBox", bbox)
                            }

                            results.put(lineJson)
                        }
                    }
                    activity.runOnUiThread {
                        webView.evaluateJavascript(
                            "window._craftMLResolve && window._craftMLResolve($results)",
                            null
                        )
                    }
                }
                .addOnFailureListener { e ->
                    activity.runOnUiThread {
                        webView.evaluateJavascript(
                            "window._craftMLReject && window._craftMLReject('${e.message}')",
                            null
                        )
                    }
                }
        } catch (e: Exception) {
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftMLReject && window._craftMLReject('${e.message}')",
                    null
                )
            }
        }
    }

    // ==================== Widget Support ====================

    private val widgetPrefs by lazy {
        activity.getSharedPreferences("craft_widget_prefs", Context.MODE_PRIVATE)
    }

    @JavascriptInterface
    fun updateWidget(dataJson: String) {
        try {
            val data = JSONObject(dataJson)
            val editor = widgetPrefs.edit()

            if (data.has("title")) {
                editor.putString("widget_title", data.getString("title"))
            }
            if (data.has("subtitle")) {
                editor.putString("widget_subtitle", data.getString("subtitle"))
            }
            if (data.has("value")) {
                editor.putString("widget_value", data.getString("value"))
            }
            if (data.has("icon")) {
                editor.putString("widget_icon", data.getString("icon"))
            }

            editor.apply()

            // Notify widgets to update
            val intent = Intent("{{PACKAGE_NAME}}.WIDGET_UPDATE")
            intent.setPackage(activity.packageName)
            activity.sendBroadcast(intent)

            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftWidgetResolve && window._craftWidgetResolve({updated: true})",
                    null
                )
            }
        } catch (e: Exception) {
            activity.runOnUiThread {
                webView.evaluateJavascript(
                    "window._craftWidgetReject && window._craftWidgetReject('${e.message}')",
                    null
                )
            }
        }
    }

    @JavascriptInterface
    fun reloadWidgets() {
        val intent = Intent("{{PACKAGE_NAME}}.WIDGET_UPDATE")
        intent.setPackage(activity.packageName)
        activity.sendBroadcast(intent)

        activity.runOnUiThread {
            webView.evaluateJavascript(
                "window._craftWidgetResolve && window._craftWidgetResolve({reloaded: true})",
                null
            )
        }
    }

    // ==================== Google Assistant / App Actions ====================

    @JavascriptInterface
    fun registerVoiceAction(phrase: String, action: String) {
        // App Actions are defined in shortcuts.xml, not dynamically
        // This stores the action for handling incoming intents
        val prefs = activity.getSharedPreferences("craft_voice_actions", Context.MODE_PRIVATE)
        prefs.edit().putString(action, phrase).apply()

        activity.runOnUiThread {
            webView.evaluateJavascript(
                "window._craftVoiceResolve && window._craftVoiceResolve({registered: true, action: '$action', phrase: '$phrase'})",
                null
            )
        }
    }

    @JavascriptInterface
    fun removeVoiceAction(action: String) {
        val prefs = activity.getSharedPreferences("craft_voice_actions", Context.MODE_PRIVATE)
        prefs.edit().remove(action).apply()

        activity.runOnUiThread {
            webView.evaluateJavascript(
                "window._craftVoiceResolve && window._craftVoiceResolve({removed: true, action: '$action'})",
                null
            )
        }
    }

    // Handle incoming voice action from Google Assistant
    fun handleVoiceAction(intent: Intent?) {
        intent?.let {
            val action = it.action
            val data = it.dataString

            if (action != null) {
                activity.runOnUiThread {
                    webView.evaluateJavascript(
                        "window.dispatchEvent(new CustomEvent('craftVoiceAction', {detail: {action: '$action', data: '$data'}}));",
                        null
                    )
                }
            }
        }
    }

    // ==================== Wear OS Connectivity ====================

    @JavascriptInterface
    fun sendToWatch(messageJson: String) {
        // Note: Full Wearable API requires separate Wear OS app
        // This provides placeholder API for future integration
        activity.runOnUiThread {
            webView.evaluateJavascript(
                "window._craftWatchReject && window._craftWatchReject('Wear OS integration requires companion app setup')",
                null
            )
        }
    }

    @JavascriptInterface
    fun updateWatchContext(contextJson: String) {
        // Note: Full Wearable API requires Data Layer API setup
        activity.runOnUiThread {
            webView.evaluateJavascript(
                "window._craftWatchReject && window._craftWatchReject('Wear OS integration requires companion app setup')",
                null
            )
        }
    }

    @JavascriptInterface
    fun isWatchReachable(): Boolean {
        // Note: Would use CapabilityClient to check for paired watch
        return false
    }

    // ==================== Deep Links ====================

    private var initialURL: String? = null

    fun setInitialURL(url: String?) {
        initialURL = url
    }

    @JavascriptInterface
    fun getInitialURL() {
        activity.runOnUiThread {
            if (initialURL != null) {
                val uri = Uri.parse(initialURL)
                val json = JSONObject().apply {
                    put("url", initialURL)
                    put("scheme", uri.scheme ?: "")
                    put("host", uri.host ?: "")
                    put("path", uri.path ?: "")
                    put("query", uri.query ?: "")
                    // Parse query parameters
                    val queryParams = JSONObject()
                    uri.queryParameterNames.forEach { name ->
                        queryParams.put(name, uri.getQueryParameter(name) ?: "")
                    }
                    put("queryParams", queryParams)
                }
                webView.evaluateJavascript(
                    "window._craftDeepLinkResolve && window._craftDeepLinkResolve($json)",
                    null
                )
            } else {
                webView.evaluateJavascript(
                    "window._craftDeepLinkResolve && window._craftDeepLinkResolve(null)",
                    null
                )
            }
        }
    }

    fun dispatchDeepLink(url: String) {
        // Store as initial URL if this is the first one
        if (initialURL == null) {
            initialURL = url
        }

        val uri = Uri.parse(url)
        val json = JSONObject().apply {
            put("url", url)
            put("scheme", uri.scheme ?: "")
            put("host", uri.host ?: "")
            put("path", uri.path ?: "")
            put("query", uri.query ?: "")
            // Parse query parameters
            val queryParams = JSONObject()
            uri.queryParameterNames.forEach { name ->
                queryParams.put(name, uri.getQueryParameter(name) ?: "")
            }
            put("queryParams", queryParams)
        }

        activity.runOnUiThread {
            webView.evaluateJavascript(
                "window.dispatchEvent(new CustomEvent('craftDeepLink', {detail: $json}));",
                null
            )
        }
    }

    // ==================== Performance Profiling ====================

    @JavascriptInterface
    fun getMemoryUsage(): String {
        val runtime = Runtime.getRuntime()
        val usedMemory = runtime.totalMemory() - runtime.freeMemory()
        val maxMemory = runtime.maxMemory()
        val totalMemory = runtime.totalMemory()

        return JSONObject().apply {
            put("usedMB", Math.round(usedMemory / 1024.0 / 1024.0 * 100) / 100.0)
            put("maxMB", Math.round(maxMemory / 1024.0 / 1024.0 * 100) / 100.0)
            put("totalMB", Math.round(totalMemory / 1024.0 / 1024.0 * 100) / 100.0)
            put("usedBytes", usedMemory)
            put("maxBytes", maxMemory)
        }.toString()
    }

    // ==================== Helpers ====================

    private fun sendEvent(event: String, data: Map<String, Any>) {
        val json = JSONObject(data).toString()
        activity.runOnUiThread {
            webView.evaluateJavascript(
                "window.dispatchEvent(new CustomEvent('$event', {detail: $json}));",
                null
            )
        }
    }

    companion object {
        const val REQUEST_CAMERA = 1001
        const val REQUEST_GALLERY = 1002
        const val REQUEST_LOCATION = 1003
        const val REQUEST_CONTACTS = 1004
        const val REQUEST_CALENDAR = 1005
        const val REQUEST_FILE_PICKER = 1006
        const val REQUEST_AUDIO = 1007
        const val REQUEST_VIDEO = 1008
        const val REQUEST_BLUETOOTH = 1009
        const val REQUEST_PICK_CONTACT = 1010
    }
}

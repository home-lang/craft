package {{PACKAGE_NAME}}

import android.app.Activity
import android.content.Context
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.work.*
import com.google.android.material.color.DynamicColors
import com.google.firebase.analytics.FirebaseAnalytics
import com.google.firebase.crashlytics.FirebaseCrashlytics
import com.google.firebase.messaging.FirebaseMessaging
import com.google.firebase.remoteconfig.FirebaseRemoteConfig
import java.util.concurrent.TimeUnit

/// Android 13+ Advanced Features

// MARK: - Jetpack Compose Integration

@Composable
fun CraftComposeApp(content: @Composable () -> Unit) {
    MaterialTheme(
        colorScheme = dynamicColorScheme(),
        typography = Typography(),
        content = content
    )
}

@Composable
fun dynamicColorScheme(): ColorScheme {
    return if (DynamicColors.isDynamicColorAvailable()) {
        dynamicDarkColorScheme()
    } else {
        darkColorScheme()
    }
}

@Composable
fun CraftWebViewComposable(
    url: String,
    modifier: Modifier = Modifier
) {
    AndroidView(
        factory = { context ->
            android.webkit.WebView(context).apply {
                settings.javaScriptEnabled = true
                loadUrl(url)
            }
        },
        modifier = modifier.fillMaxSize()
    )
}

// MARK: - Material You Dynamic Colors

class DynamicColorManager(private val activity: Activity) {

    fun applyDynamicColors() {
        if (DynamicColors.isDynamicColorAvailable()) {
            DynamicColors.applyToActivityIfAvailable(activity)
        }
    }

    fun isDynamicColorAvailable(): Boolean {
        return DynamicColors.isDynamicColorAvailable()
    }
}

// MARK: - Predictive Back Gesture (Android 13+)

class PredictiveBackHandler(private val activity: Activity) {

    fun enablePredictiveBack() {
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.TIRAMISU) {
            activity.onBackPressedDispatcher.addCallback(activity, object : androidx.activity.OnBackPressedCallback(true) {
                override fun handleOnBackPressed() {
                    // Handle predictive back gesture
                    // Can animate the exit transition
                    isEnabled = false
                    activity.onBackPressedDispatcher.onBackPressed()
                }
            })
        }
    }
}

// MARK: - Per-App Language Preferences (Android 13+)

class LanguageManager(private val context: Context) {

    fun setAppLanguage(languageCode: String) {
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.TIRAMISU) {
            val localeList = android.os.LocaleList(java.util.Locale.forLanguageTag(languageCode))
            context.getSystemService(android.app.LocaleManager::class.java)
                ?.applicationLocales = localeList
        }
    }

    fun getAppLanguage(): String? {
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.TIRAMISU) {
            val locales = context.getSystemService(android.app.LocaleManager::class.java)
                ?.applicationLocales
            return locales?.get(0)?.toLanguageTag()
        }
        return null
    }
}

// MARK: - Photo Picker (Android 13+)

class PhotoPickerManager(private val activity: Activity) {

    fun launchPhotoPicker(maxItems: Int = 1, callback: (List<android.net.Uri>) -> Unit) {
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.TIRAMISU) {
            val intent = android.content.Intent(android.provider.MediaStore.ACTION_PICK_IMAGES).apply {
                putExtra(android.provider.MediaStore.EXTRA_PICK_IMAGES_MAX, maxItems)
            }
            // Launch intent and handle result
        }
    }
}

// MARK: - Notification Permission (Android 13+)

class NotificationPermissionManager(private val activity: Activity) {

    fun requestNotificationPermission(callback: (Boolean) -> Unit) {
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.TIRAMISU) {
            if (androidx.core.app.ActivityCompat.checkSelfPermission(
                    activity,
                    android.Manifest.permission.POST_NOTIFICATIONS
                ) != android.content.pm.PackageManager.PERMISSION_GRANTED
            ) {
                androidx.core.app.ActivityCompat.requestPermissions(
                    activity,
                    arrayOf(android.Manifest.permission.POST_NOTIFICATIONS),
                    100
                )
            } else {
                callback(true)
            }
        } else {
            callback(true)
        }
    }

    fun hasNotificationPermission(): Boolean {
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.TIRAMISU) {
            return androidx.core.app.ActivityCompat.checkSelfPermission(
                activity,
                android.Manifest.permission.POST_NOTIFICATIONS
            ) == android.content.pm.PackageManager.PERMISSION_GRANTED
        }
        return true
    }
}

// MARK: - Foreground Services

class ForegroundServiceManager(private val context: Context) {

    fun startForegroundService(
        serviceClass: Class<*>,
        notificationTitle: String,
        notificationText: String
    ) {
        val intent = android.content.Intent(context, serviceClass)
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
            context.startForegroundService(intent)
        } else {
            context.startService(intent)
        }
    }

    fun stopForegroundService(serviceClass: Class<*>) {
        val intent = android.content.Intent(context, serviceClass)
        context.stopService(intent)
    }
}

// MARK: - WorkManager for Background Tasks

class BackgroundTaskManager(private val context: Context) {

    fun scheduleOneTimeWork(
        tag: String,
        initialDelay: Long = 0,
        requiresCharging: Boolean = false,
        requiresWifi: Boolean = false
    ) {
        val constraints = Constraints.Builder()
            .setRequiresCharging(requiresCharging)
            .setRequiredNetworkType(if (requiresWifi) NetworkType.UNMETERED else NetworkType.CONNECTED)
            .build()

        val workRequest = OneTimeWorkRequestBuilder<CraftWorker>()
            .setConstraints(constraints)
            .setInitialDelay(initialDelay, TimeUnit.MILLISECONDS)
            .addTag(tag)
            .build()

        WorkManager.getInstance(context).enqueue(workRequest)
    }

    fun schedulePeriodicWork(
        tag: String,
        intervalMinutes: Long,
        requiresCharging: Boolean = false
    ) {
        val constraints = Constraints.Builder()
            .setRequiresCharging(requiresCharging)
            .build()

        val workRequest = PeriodicWorkRequestBuilder<CraftWorker>(
            intervalMinutes, TimeUnit.MINUTES
        )
            .setConstraints(constraints)
            .addTag(tag)
            .build()

        WorkManager.getInstance(context).enqueue(workRequest)
    }

    fun cancelWork(tag: String) {
        WorkManager.getInstance(context).cancelAllWorkByTag(tag)
    }

    class CraftWorker(context: Context, params: WorkerParameters) : Worker(context, params) {
        override fun doWork(): Result {
            // Perform background task
            return Result.success()
        }
    }
}

// MARK: - Firebase Integration

class FirebaseManager(private val context: Context) {

    private val analytics: FirebaseAnalytics by lazy {
        FirebaseAnalytics.getInstance(context)
    }

    private val crashlytics: FirebaseCrashlytics by lazy {
        FirebaseCrashlytics.getInstance()
    }

    private val remoteConfig: FirebaseRemoteConfig by lazy {
        FirebaseRemoteConfig.getInstance()
    }

    // Analytics
    fun logEvent(eventName: String, params: Map<String, Any>) {
        val bundle = android.os.Bundle().apply {
            params.forEach { (key, value) ->
                when (value) {
                    is String -> putString(key, value)
                    is Int -> putInt(key, value)
                    is Long -> putLong(key, value)
                    is Double -> putDouble(key, value)
                    is Boolean -> putBoolean(key, value)
                }
            }
        }
        analytics.logEvent(eventName, bundle)
    }

    fun setUserProperty(name: String, value: String) {
        analytics.setUserProperty(name, value)
    }

    // Crashlytics
    fun logCrash(message: String) {
        crashlytics.log(message)
    }

    fun recordException(throwable: Throwable) {
        crashlytics.recordException(throwable)
    }

    fun setUserId(userId: String) {
        crashlytics.setUserId(userId)
    }

    // Remote Config
    fun fetchRemoteConfig(callback: (Boolean) -> Unit) {
        remoteConfig.fetchAndActivate()
            .addOnCompleteListener { task ->
                callback(task.isSuccessful)
            }
    }

    fun getString(key: String): String {
        return remoteConfig.getString(key)
    }

    fun getBoolean(key: String): Boolean {
        return remoteConfig.getBoolean(key)
    }

    fun getLong(key: String): Long {
        return remoteConfig.getLong(key)
    }

    // FCM
    fun getFirebaseToken(callback: (String?) -> Unit) {
        FirebaseMessaging.getInstance().token
            .addOnCompleteListener { task ->
                if (task.isSuccessful) {
                    callback(task.result)
                } else {
                    callback(null)
                }
            }
    }

    fun subscribeToTopic(topic: String) {
        FirebaseMessaging.getInstance().subscribeToTopic(topic)
    }

    fun unsubscribeFromTopic(topic: String) {
        FirebaseMessaging.getInstance().unsubscribeFromTopic(topic)
    }
}

// MARK: - Bottom Sheet

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CraftBottomSheet(
    sheetContent: @Composable ColumnScope.() -> Unit,
    content: @Composable () -> Unit
) {
    val sheetState = rememberModalBottomSheetState()
    var showBottomSheet by remember { mutableStateOf(false) }

    if (showBottomSheet) {
        ModalBottomSheet(
            onDismissRequest = { showBottomSheet = false },
            sheetState = sheetState
        ) {
            sheetContent()
        }
    }

    content()
}

// MARK: - Navigation Drawer

@Composable
fun CraftNavigationDrawer(
    drawerContent: @Composable ColumnScope.() -> Unit,
    content: @Composable () -> Unit
) {
    val drawerState = rememberDrawerState(DrawerValue.Closed)
    val scope = rememberCoroutineScope()

    ModalNavigationDrawer(
        drawerState = drawerState,
        drawerContent = {
            ModalDrawerSheet {
                drawerContent()
            }
        }
    ) {
        content()
    }
}

// MARK: - Bridge Integration

fun CraftBridge.initializeAdvancedFeatures() {
    // Initialize all advanced Android features
    DynamicColorManager(activity).applyDynamicColors()
    PredictiveBackHandler(activity).enablePredictiveBack()
}

fun CraftBridge.setupFirebase() {
    // Setup Firebase services
    // Called from MainActivity onCreate
}
